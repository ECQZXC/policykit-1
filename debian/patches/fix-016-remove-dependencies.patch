Index: b/src/libda/libdeepin-authenticate.h
===================================================================
--- /dev/null
+++ b/src/libda/libdeepin-authenticate.h
@@ -0,0 +1,4 @@
+#include "./auth/auth.h"
+#include "./auth/text.h"
+#include "./encrypt/aes.h"
+#include "./encrypt/rsa.h"
\ No newline at end of file
Index: b/src/libda/auth/auth-priv.h
===================================================================
--- /dev/null
+++ b/src/libda/auth/auth-priv.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "com.deepin.daemon.Authenticate.h"
+#include "com.deepin.daemon.Authenticate.Session.h"
+#include "../encrypt/aes.h"
+#include "../encrypt/rsa.h"
+#include "auth.h"
+
+struct _auth_proxy {
+    gchar *username;
+    GDBusConnection *con;
+    GDBusProxy *authenticate_proxy;
+    GDBusProxy *session_proxy;
+    gchar *session_path;
+    log_cb log_callback;
+    signal_limit_updated_cb sig_limit_update_cb;
+    void *limit_cb_userdata;
+    signal_status_cb sig_status_cb;
+    void *signal_cb_userdata;
+
+    gchar *pubkey;
+    gint enc_type;
+    GVariant *enc_method;
+    gchar *symmetricKey;
+    pub_key *key;
+};
+
+#define MAX_BUFF_SIZE (512)
+
+#define LOG_CB(obj, fmt, args...)                                                                  \
+    do {                                                                                           \
+        if (obj->log_callback) obj->log_callback(fmt, ##args);                                     \
+    } while (0)
Index: b/src/libda/auth/auth.c
===================================================================
--- /dev/null
+++ b/src/libda/auth/auth.c
@@ -0,0 +1,980 @@
+#include "com.deepin.daemon.Authenticate.h"
+#include "com.deepin.daemon.Authenticate.Session.h"
+#include <stdio.h>
+#include <json-c/json.h>
+#include "auth-priv.h"
+
+#define DA_DBUS_SERVER "com.deepin.daemon.Authenticate"
+#define DA_DBUS_MANAGER_PATH "/com/deepin/daemon/Authenticate"
+
+#define DA_DBUS_SESSION_INTERFACE "com.deepin.daemon.Authenticate.Session"
+
+int da_set_log_callback(da_proxy *proxy, log_cb cb) {
+    if (proxy == NULL || cb == NULL) {
+        return -1;
+    }
+    proxy->log_callback = cb;
+    return 0;
+}
+static int limit_json_deal(gchar *in, da_limit_info **limits, int *limit_len) {
+    if (in == NULL || limits == NULL) {
+        return -1;
+    }
+    json_object *pobj = NULL;
+    pobj = json_tokener_parse(in);
+
+    int ele_num = json_object_array_length(pobj);
+    *limit_len = ele_num;
+
+    *limits = (da_limit_info *)malloc(sizeof(da_limit_info) * ele_num);
+
+    int error_ret = 0;
+    for (int i = 0; i < ele_num; i++) {
+        json_object *ele_json = json_object_array_get_idx(pobj, i);
+        if (ele_json) {
+            json_object *json_type = NULL;
+            json_object *json_flag = NULL;
+            json_object *json_unlock_secs = NULL;
+            json_object *json_max_tries = NULL;
+            json_object *json_num_failures = NULL;
+            json_object *json_locked = NULL;
+            json_object *json_unlockT_time = NULL;
+            json_bool ret = json_object_object_get_ex(ele_json, "type", &json_type);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "flag", &json_flag);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "unlockSecs", &json_unlock_secs);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "maxTries", &json_max_tries);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "numFailures", &json_num_failures);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "locked", &json_locked);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            ret = json_object_object_get_ex(ele_json, "unlockTime", &json_unlockT_time);
+            if (!ret) {
+                error_ret = -1;
+                break;
+            }
+            g_strlcpy(((*limits) + i)->type, json_object_get_string(json_type), 64);
+            ((*limits) + i)->flag = json_object_get_int(json_flag);
+            ((*limits) + i)->unlock_secs = json_object_get_int(json_unlock_secs);
+            ((*limits) + i)->max_tries = json_object_get_int(json_max_tries);
+            ((*limits) + i)->fail_num = json_object_get_int(json_num_failures);
+            ((*limits) + i)->locked = json_object_get_boolean(json_locked);
+            g_strlcpy(((*limits) + i)->unlock_time, json_object_get_string(json_unlockT_time), 64);
+        }
+    }
+    json_object_put(pobj);
+
+    return error_ret;
+}
+
+gboolean signal_limit_updated_handler(ComDeepinDaemonAuthenticate *object,
+                                      gchar *value,
+                                      gpointer userdata) {
+    g_return_val_if_fail(IS_COM_DEEPIN_DAEMON_AUTHENTICATE(object), FALSE);
+
+    da_proxy *proxy = (da_proxy *)userdata;
+
+    if (g_strcmp0(value, proxy->username)) {
+        return FALSE;
+    }
+
+    LOG_CB(proxy, "signal_limit_updated_handler invoked! %s.\n", value);
+
+    if (proxy->sig_limit_update_cb) {
+        da_limit_info *dli = NULL;
+        int dli_num = 0;
+
+        GError *callError = NULL;
+        gchar *out_limits = NULL;
+        com_deepin_daemon_authenticate_call_get_limits_sync(
+                (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy),
+                value,
+                &out_limits,
+                NULL,
+                &callError);
+        if (callError != NULL) {
+            g_error_free(callError);
+            return -1;
+        }
+        if (out_limits == NULL) {
+            return -1;
+        }
+
+        limit_json_deal(out_limits, &dli, &dli_num);
+        proxy->sig_limit_update_cb(proxy->limit_cb_userdata, dli, dli_num);
+
+        if (dli) {
+            free(dli);
+        }
+    }
+
+    return TRUE;
+}
+
+bool is_valid_auth_flag(int auth_flag) {
+    if (auth_flag == AUTH_FLAG_PASSWORD || auth_flag == AUTH_FLAG_FINGERPRINT ||
+        auth_flag == AUTH_FLAG_AD || auth_flag == AUTH_FLAG_FACE ||
+        auth_flag == AUTH_FLAG_FINGERVEIN || auth_flag == AUTH_FLAG_IRIS ||
+        auth_flag == AUTH_FLAG_UKEY) {
+        return true;
+    }
+    return false;
+}
+
+da_limit_info *da_get_auth_limit_info(da_limit_info *dli, int dli_num, DA_AUTH_FLAG auth_flag) {
+    if (!dli || !is_valid_auth_flag(auth_flag) || auth_flag == AUTH_FLAG_ALL) {
+        return NULL;
+    }
+
+    for (int i = 0; i < dli_num; i++) {
+        if (&dli[i]) {
+            if (dli[i].flag == auth_flag) {
+                return &dli[i];
+            }
+        }
+    }
+
+    return NULL;
+}
+
+// Released by caller
+// if err is NULL, ignore errors
+static void error_dup(da_error **err, GError *callError) {
+    if (err != NULL && callError != NULL) {
+        *err = (da_error *)g_malloc(sizeof(da_error));
+        (*err)->msg = g_strdup(callError->message);
+        (*err)->code = callError->code;
+    }
+}
+
+// Released by caller
+// if err is NULL, ignore errors
+static void error_new(da_error **err, char *msg) {
+    if (err != NULL) {
+        *err = (da_error *)g_malloc(sizeof(da_error));
+        (*err)->msg = g_strdup(msg);
+        (*err)->code = -1;
+    }
+}
+
+static gboolean has_valid_authenticate_proxy(da_proxy *proxy) {
+    g_return_val_if_fail((proxy != NULL), FALSE);
+    g_return_val_if_fail(IS_COM_DEEPIN_DAEMON_AUTHENTICATE(proxy->authenticate_proxy), FALSE);
+    return TRUE;
+}
+static gboolean has_valid_session_proxy(da_proxy *proxy) {
+    g_return_val_if_fail((proxy != NULL), FALSE);
+    g_return_val_if_fail(IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION(proxy->session_proxy), FALSE);
+    return TRUE;
+}
+
+// da_dbus_proxy_new: 创建manager dbus接口proxy
+da_proxy *da_dbus_proxy_new() {
+    da_proxy *proxy = (da_proxy *)g_malloc(sizeof(da_proxy));
+    proxy->limit_cb_userdata = NULL;
+    proxy->log_callback = NULL;
+    proxy->sig_status_cb = NULL;
+    memset(proxy, 0, sizeof(da_proxy));
+
+    GError *connerror = NULL;
+    proxy->con = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &connerror);
+    if (connerror != NULL) {
+        g_error_free(connerror);
+        return NULL;
+    }
+    GError *callError = NULL;
+    proxy->authenticate_proxy =
+            (GDBusProxy *)com_deepin_daemon_authenticate_proxy_new_sync(proxy->con,
+                                                                        G_DBUS_PROXY_FLAGS_NONE,
+                                                                        DA_DBUS_SERVER,
+                                                                        DA_DBUS_MANAGER_PATH,
+                                                                        NULL,
+                                                                        &callError);
+    if (callError != NULL) {
+        g_error_free(callError);
+        g_free(proxy);
+        return NULL;
+    }
+    if (proxy->authenticate_proxy == NULL) {
+        g_free(proxy);
+        return NULL;
+    }
+
+    g_signal_connect((ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy),
+                     "limit-updated",
+                     G_CALLBACK(signal_limit_updated_handler),
+                     proxy);
+    return proxy;
+}
+
+gboolean signal_status_handler(ComDeepinDaemonAuthenticateSession *object,
+                               gint flag,
+                               gint status,
+                               gchar *msg,
+                               gpointer userdata) {
+    g_return_val_if_fail(IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION(object), FALSE);
+
+    da_proxy *proxy = (da_proxy *)userdata;
+
+    LOG_CB(proxy, "signal_status_handler invoked!\n");
+
+    if (proxy->sig_status_cb) {
+        proxy->sig_status_cb(proxy->signal_cb_userdata, flag, status, msg);
+    }
+
+    return TRUE;
+}
+
+// da_create_authenticate： 创建session dbus接口proxy
+int da_create_authenticate(da_proxy *proxy,
+                           const char *username,
+                           int flags,
+                           int app_type,
+                           da_error **err) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+
+    GError *callError = NULL;
+    gchar *out_path = NULL;
+    com_deepin_daemon_authenticate_call_authenticate_sync(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy),
+            username,
+            flags,
+            app_type,
+            &out_path,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    if (out_path == NULL) {
+        error_new(err, "call dbus-authenticate failed.");
+        return -1;
+    }
+
+    proxy->session_proxy = (GDBusProxy *)com_deepin_daemon_authenticate_session_proxy_new_sync(
+            proxy->con,
+            G_DBUS_PROXY_FLAGS_NONE,
+            DA_DBUS_SERVER,
+            out_path,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        g_free(out_path);
+        return -1;
+    }
+    if (proxy->session_proxy == NULL) {
+        error_new(err, "create session failed.");
+        g_free(out_path);
+        return -1;
+    }
+    proxy->session_path = out_path;
+    proxy->username = g_strdup(username);
+
+    GVariant *args = g_variant_new_array(G_VARIANT_TYPE_INT32, NULL, 0);
+    com_deepin_daemon_authenticate_session_call_encrypt_key_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            0,
+            args,
+            &proxy->enc_type,
+            &proxy->enc_method,
+            &proxy->pubkey,
+            NULL,
+            &callError);
+    // g_variant_unref(args);
+
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        g_free(out_path);
+        return -1;
+    }
+
+    proxy->key = create_pub_key();
+
+    int ret = gen_rsa_pubkey(proxy->key, proxy->pubkey);
+    if (ret) {
+        error_new(err, "gen rsa error");
+        g_free(out_path);
+        return -1;
+    }
+
+    create_symmetric_key(&proxy->symmetricKey);
+
+    gchar *encrypt_symmetricKey = NULL;
+    int len = rsa_encrypt_data(proxy->key, proxy->symmetricKey, (char **)&encrypt_symmetricKey);
+
+    GBytes *bytes = g_bytes_new(encrypt_symmetricKey, len);
+
+    GVariant *enc_symmetricKey_variant =
+            g_variant_new_from_bytes(G_VARIANT_TYPE_BYTESTRING, bytes, TRUE);
+
+    com_deepin_daemon_authenticate_session_call_set_symmetric_key_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            enc_symmetricKey_variant,
+            NULL,
+            &callError);
+
+    g_free(encrypt_symmetricKey);
+    g_bytes_unref(bytes);
+    // g_variant_unref(enc_symmetricKey_variant);
+
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        g_free(out_path);
+        return -1;
+    }
+
+    g_signal_connect((ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+                     "status",
+                     G_CALLBACK(signal_status_handler),
+                     proxy);
+
+    return 0;
+}
+
+int da_quit_authenticate(da_proxy *proxy, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_end_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            -1,
+            NULL,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    if (proxy->session_proxy != NULL) {
+        g_object_unref(proxy->session_proxy);
+    }
+    if (proxy->session_path != NULL) {
+        g_free(proxy->session_path);
+    }
+    return 0;
+}
+
+static int da_dbus_prop_get_string(GDBusProxy *dbus_proxy,
+                                   gchar *interface,
+                                   gchar *name,
+                                   gchar **value) {
+    if (dbus_proxy == NULL || interface == NULL || name == NULL || value == NULL) {
+        return -1;
+    }
+    GError *callError = NULL;
+    GVariant *ret1 = g_dbus_proxy_call_sync(dbus_proxy,
+                                            "org.freedesktop.DBus.Properties.Get",
+                                            g_variant_new("(ss)", interface, name),
+                                            G_DBUS_CALL_FLAGS_NONE,
+                                            -1,
+                                            NULL,
+                                            &callError);
+    if (callError != NULL) {
+        ;
+        g_error_free(callError);
+        return -1;
+    }
+    GVariant *ret2 = NULL;
+    g_variant_get(ret1, "(v)", &ret2);
+    g_variant_get(ret2, "s", value);
+    g_variant_unref(ret1);
+    g_variant_unref(ret2);
+    return 0;
+}
+
+static int da_dbus_prop_get_gvariant(GDBusProxy *dbus_proxy,
+                                     gchar *interface,
+                                     gchar *name,
+                                     GVariant **value) {
+    if (dbus_proxy == NULL || interface == NULL || name == NULL || value == NULL) {
+        return -1;
+    }
+    GError *callError = NULL;
+    GVariant *ret1 = g_dbus_proxy_call_sync(dbus_proxy,
+                                            "org.freedesktop.DBus.Properties.Get",
+                                            g_variant_new("(ss)", interface, name),
+                                            G_DBUS_CALL_FLAGS_NONE,
+                                            -1,
+                                            NULL,
+                                            &callError);
+    if (callError != NULL) {
+        ;
+        g_error_free(callError);
+        return -1;
+    }
+    g_variant_get(ret1, "(v)", value);
+    g_variant_unref(ret1);
+    return 0;
+}
+
+static int da_dbus_prop_get_int(GDBusProxy *dbus_proxy,
+                                gchar *interface,
+                                gchar *name,
+                                gint *value) {
+    if (dbus_proxy == NULL || interface == NULL || name == NULL || value == NULL) {
+        return -1;
+    }
+    GError *callError = NULL;
+    GVariant *ret1 = g_dbus_proxy_call_sync(dbus_proxy,
+                                            "org.freedesktop.DBus.Properties.Get",
+                                            g_variant_new("(ss)", interface, name),
+                                            G_DBUS_CALL_FLAGS_NONE,
+                                            -1,
+                                            NULL,
+                                            &callError);
+    if (callError != NULL) {
+        g_error_free(callError);
+        return -1;
+    }
+    GVariant *ret2 = NULL;
+    g_variant_get(ret1, "(v)", &ret2);
+    g_variant_get(ret2, "i", value);
+    g_variant_unref(ret1);
+    g_variant_unref(ret2);
+    return 0;
+}
+
+static int da_dbus_prop_get_bool(GDBusProxy *dbus_proxy,
+                                 gchar *interface,
+                                 gchar *name,
+                                 gboolean *value) {
+    if (dbus_proxy == NULL || interface == NULL || name == NULL || value == NULL) {
+        return -1;
+    }
+    GError *callError = NULL;
+    GVariant *ret1 = g_dbus_proxy_call_sync(dbus_proxy,
+                                            "org.freedesktop.DBus.Properties.Get",
+                                            g_variant_new("(ss)", interface, name),
+                                            G_DBUS_CALL_FLAGS_NONE,
+                                            -1,
+                                            NULL,
+                                            &callError);
+    if (callError != NULL) {
+        g_error_free(callError);
+        return -1;
+    }
+    GVariant *ret2 = NULL;
+    g_variant_get(ret1, "(v)", &ret2);
+    g_variant_get(ret2, "b", value);
+    g_variant_unref(ret1);
+    g_variant_unref(ret2);
+    return 0;
+}
+
+int da_get_limits(da_proxy *proxy,
+                  const char *username,
+                  da_limit_info **limits,
+                  int *limit_len,
+                  da_error **err) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+
+    GError *callError = NULL;
+    gchar *out_limits = NULL;
+    com_deepin_daemon_authenticate_call_get_limits_sync(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy),
+            username,
+            &out_limits,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    if (out_limits == NULL) {
+        error_new(err, "call GetLimit failed.");
+        return -1;
+    }
+
+    gint ret = limit_json_deal(out_limits, limits, limit_len);
+    g_free(out_limits);
+    return ret;
+}
+
+int da_pre_one_key_login(da_proxy *proxy, int flag, char *result, int result_len, da_error **err) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+    if (result == NULL || result_len <= 0) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+    gchar *out_result;
+    com_deepin_daemon_authenticate_call_pre_one_key_login_sync(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy),
+            flag,
+            &out_result,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    if (out_result == NULL) {
+        error_new(err, "call pre_one_key_login failed.");
+        return -1;
+    }
+    g_strlcpy(result, out_result, result_len);
+    g_free(out_result);
+    return 0;
+}
+
+static int da_auth_dbus_prop_get_string(GDBusProxy *dbus_proxy, gchar *name, gchar **value) {
+    return da_dbus_prop_get_string(dbus_proxy, "com.deepin.daemon.Authenticate", name, value);
+}
+static int da_auth_dbus_prop_get_int(GDBusProxy *dbus_proxy, gchar *name, gint *value) {
+    return da_dbus_prop_get_int(dbus_proxy, "com.deepin.daemon.Authenticate", name, value);
+}
+
+int da_prop_get_support_encrypts(da_proxy *proxy, char *result, int result_len) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+    if (result == NULL || result_len <= 0) {
+        return -1;
+    }
+
+#ifdef DBUS_PROPERTY_CACHE
+    const gchar *value = com_deepin_daemon_authenticate_get_support_encrypts(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy));
+    g_strlcpy(result, value, result_len);
+#else
+    gchar *value = NULL;
+    if (da_auth_dbus_prop_get_string(proxy->authenticate_proxy, "SupportEncrypts", &value)) {
+        return -1;
+    }
+    g_strlcpy(result, value, result_len);
+    g_free(value);
+#endif
+    return 0;
+}
+
+int da_prop_get_framework_state(da_proxy *proxy, int *result) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+    if (result == NULL) {
+        return -1;
+    }
+    gint value = 0;
+#ifdef DBUS_PROPERTY_CACHE
+    value = com_deepin_daemon_authenticate_get_framework_state(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy));
+#else
+    if (da_auth_dbus_prop_get_int(proxy->authenticate_proxy, "FrameworkState", &value)) {
+        return -1;
+    }
+#endif
+    *result = value;
+    return 0;
+}
+
+int da_prop_get_supported_flags(da_proxy *proxy, int *result) {
+    g_return_val_if_fail(has_valid_authenticate_proxy(proxy), -1);
+    if (result == NULL) {
+        return -1;
+    }
+    gint value = 0;
+#ifdef DBUS_PROPERTY_CACHE
+    gint value = com_deepin_daemon_authenticate_get_supported_flags(
+            (ComDeepinDaemonAuthenticate *)(proxy->authenticate_proxy));
+#else
+    if (da_auth_dbus_prop_get_int(proxy->authenticate_proxy, "SupportedFlags", &value)) {
+        return -1;
+    }
+#endif
+    *result = value;
+    return 0;
+}
+
+int da_signal_connect_limit_updated(da_proxy *proxy, signal_limit_updated_cb cb, void *userdata) {
+    if (proxy == NULL || cb == NULL) {
+        return -1;
+    }
+    proxy->sig_limit_update_cb = cb;
+    proxy->limit_cb_userdata = userdata;
+    return 0;
+}
+
+int da_session_set_token(da_proxy *proxy,
+                         const int auth_type,
+                         const char *password,
+                         da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (password == NULL) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+
+    gchar *encrypt_password;
+    int encrypt_password_len;
+
+    aes_cbc_encrypt(password,
+                    strlen(password),
+                    proxy->symmetricKey,
+                    strlen(proxy->symmetricKey),
+                    &encrypt_password,
+                    &encrypt_password_len);
+    GBytes *bytes = g_bytes_new(encrypt_password, encrypt_password_len);
+
+    GVariant *enc_token_variant = g_variant_new_from_bytes(G_VARIANT_TYPE_BYTESTRING, bytes, TRUE);
+
+    com_deepin_daemon_authenticate_session_call_set_token_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            auth_type,
+            enc_token_variant,
+            NULL,
+            &callError);
+    free(encrypt_password);
+
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_end(da_proxy *proxy, int flag, int *out_failNum, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (out_failNum == NULL) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_end_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            flag,
+            out_failNum,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_get_result(da_proxy *proxy, int *result, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_get_result_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            result,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_privileges_disable(da_proxy *proxy, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_privileges_disable_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_privileges_enable(da_proxy *proxy,
+                                 const char *master_path,
+                                 bool *enabled,
+                                 da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (enabled == NULL || master_path == NULL) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_privileges_enable_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            master_path,
+            (gboolean *)enabled,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_set_quit_flag(da_proxy *proxy, int method, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_set_quit_flag_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            method,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+int da_session_start(da_proxy *proxy, int flag, int timeout, int *failNum, da_error **err) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (failNum == NULL) {
+        error_new(err, "parameter error.");
+        return -1;
+    }
+    GError *callError = NULL;
+    com_deepin_daemon_authenticate_session_call_start_sync(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy),
+            flag,
+            timeout,
+            failNum,
+            NULL,
+            &callError);
+    if (callError != NULL) {
+        error_dup(err, callError);
+        g_error_free(callError);
+        return -1;
+    }
+    return 0;
+}
+
+static int da_session_dbus_prop_get_string(GDBusProxy *dbus_proxy, gchar *name, gchar **value) {
+    return da_dbus_prop_get_string(dbus_proxy, "com.deepin.daemon.Authenticate.Session", name, value);
+}
+static int da_session_dbus_prop_get_int(GDBusProxy *dbus_proxy, gchar *name, gint *value) {
+    return da_dbus_prop_get_int(dbus_proxy, "com.deepin.daemon.Authenticate.Session", name, value);
+}
+static int da_session_dbus_prop_get_bool(GDBusProxy *dbus_proxy, gchar *name, gboolean *value) {
+    return da_dbus_prop_get_bool(dbus_proxy, "com.deepin.daemon.Authenticate.Session", name, value);
+}
+static int da_session_dbus_prop_get_gvariant(GDBusProxy *dbus_proxy,
+                                             gchar *name,
+                                             GVariant **value) {
+    return da_dbus_prop_get_gvariant(dbus_proxy, "com.deepin.daemon.Authenticate.Session", name, value);
+}
+
+int da_prop_get_is_MFA(da_proxy *proxy, bool *result) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL) {
+        return -1;
+    }
+    gboolean value = FALSE;
+#ifdef DBUS_PROPERTY_CACHE
+    value = com_deepin_daemon_authenticate_session_get_is_mfa(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+#else
+    if (da_session_dbus_prop_get_bool(proxy->session_proxy, "IsMFA", &value)) {
+        return -1;
+    }
+#endif
+    *result = value;
+    return 0;
+}
+int da_prop_get_prompt(da_proxy *proxy, char *result, int result_len) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL || result_len <= 0) {
+        return -1;
+    }
+#ifdef DBUS_PROPERTY_CACHE
+    const gchar *ret = com_deepin_daemon_authenticate_session_get_prompt(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+    g_strlcpy(result, ret, result_len);
+#else
+    gchar *value = NULL;
+    if (da_session_dbus_prop_get_string(proxy->session_proxy, "Prompt", &value)) {
+        return -1;
+    }
+    g_strlcpy(result, value, result_len);
+    g_free(value);
+#endif
+    return 0;
+}
+int da_prop_get_factors_info(da_proxy *proxy, da_factor_info **result, int *factor_info_len) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL) {
+        return -1;
+    }
+    GVariant *value = NULL;
+#ifdef DBUS_PROPERTY_CACHE
+    value = com_deepin_daemon_authenticate_session_dup_factors_info(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+#else
+    if (da_session_dbus_prop_get_gvariant(proxy->session_proxy, "FactorsInfo", &value)) {
+        return -1;
+    }
+#endif
+    GVariantIter *iter = NULL;
+    g_variant_get(value, "a(iiib)", &iter);
+    g_variant_unref(value);
+    if (iter == NULL) {
+        return -1;
+    }
+    gsize num = g_variant_iter_n_children(iter);
+
+    if (num <= 0) {
+        return -1;
+    }
+
+    gint curIndex = 0;
+    *result = (da_factor_info *)malloc(sizeof(da_factor_info) * num);
+    *factor_info_len = num;
+
+    while (g_variant_iter_next(iter,
+                               "(iiib)",
+                               &((*result)[curIndex].auth_type),
+                               &((*result)[curIndex].priority),
+                               &((*result)[curIndex].input_type),
+                               &((*result)[curIndex].required))) {
+        curIndex++;
+    }
+    g_variant_iter_free(iter);
+    return 0;
+}
+
+int da_prop_get_username(da_proxy *proxy, char *result, int result_len) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL || result_len <= 0) {
+        return -1;
+    }
+#ifdef DBUS_PROPERTY_CACHE
+    const gchar *ret = com_deepin_daemon_authenticate_session_get_username(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+    g_strlcpy(result, ret, result_len);
+#else
+    gchar *value = NULL;
+    if (da_session_dbus_prop_get_string(proxy->session_proxy, "Username", &value)) {
+        return -1;
+    }
+    g_strlcpy(result, value, result_len);
+    g_free(value);
+#endif
+    return 0;
+}
+int da_prop_get_PIN_len(da_proxy *proxy, int *result) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL) {
+        return -1;
+    }
+    gint value = 0;
+#ifdef DBUS_PROPERTY_CACHE
+    value = com_deepin_daemon_authenticate_session_get_pinlen(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+#else
+    if (da_session_dbus_prop_get_int(proxy->session_proxy, "PINLen", &value)) {
+        return -1;
+    }
+#endif
+    *result = value;
+    return 0;
+}
+int da_prop_get_prg_path(da_proxy *proxy, char *result, int result_len) {
+    g_return_val_if_fail(has_valid_session_proxy(proxy), -1);
+    if (result == NULL || result_len <= 0) {
+        return -1;
+    }
+#ifdef DBUS_PROPERTY_CACHE
+    const gchar *ret = com_deepin_daemon_authenticate_session_get_prg_path(
+            (ComDeepinDaemonAuthenticateSession *)(proxy->session_proxy));
+    g_strlcpy(result, ret, result_len);
+#else
+    gchar *value = NULL;
+    if (da_session_dbus_prop_get_string(proxy->session_proxy, "PrgPath", &value)) {
+        return -1;
+    }
+    g_strlcpy(result, value, result_len);
+    g_free(value);
+#endif
+    return 0;
+}
+
+int da_session_signal_connect_status(da_proxy *proxy, signal_status_cb cb, void *userdata) {
+    if (cb == NULL || proxy == NULL) {
+        return -1;
+    }
+    proxy->sig_status_cb = cb;
+    proxy->signal_cb_userdata = userdata;
+    return 0;
+}
+
+void da_error_free(da_error *err) {
+    if (err) {
+        if (err->msg) {
+            g_free(err->msg);
+        }
+        free(err);
+    }
+}
+
+void da_dbus_proxy_free(da_proxy *proxy) {
+    if (!proxy) return;
+
+    if (proxy->username) {
+        g_free(proxy->username);
+    }
+
+    if (proxy->authenticate_proxy) g_object_unref(proxy->authenticate_proxy);
+
+    if (proxy->session_proxy) g_object_unref(proxy->session_proxy);
+
+    if (proxy->session_path) g_free(proxy->session_path);
+
+    if (proxy->pubkey) {
+        g_free(proxy->pubkey);
+    }
+
+    if (proxy->enc_method) {
+        g_variant_unref(proxy->enc_method);
+    }
+
+    if (proxy->symmetricKey) {
+        g_free(proxy->symmetricKey);
+    }
+
+    pub_key_free(proxy->key);
+
+    free(proxy);
+
+    proxy = NULL;
+}
\ No newline at end of file
Index: b/src/libda/auth/auth.h
===================================================================
--- /dev/null
+++ b/src/libda/auth/auth.h
@@ -0,0 +1,136 @@
+#pragma once
+
+#include <gio/gio.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+G_BEGIN_DECLS
+
+typedef enum {
+    STATUS_CODE_SUCCESS = 0,
+    STATUS_CODE_FAILURE,
+    STATUS_CODE_CANCEL,
+    STATUS_CODE_TIMEOUT,
+    STATUS_CODE_ERROR,
+    STATUS_CODE_VERIFY,
+    STATUS_CODE_EXCEPTION,
+    STATUS_CODE_PROMPT,
+    STATUS_CODE_STARTED,
+    STATUS_CODE_ENDED,
+    STATUS_CODE_LOCKED,
+    STATUS_CODE_RECOVER,
+    STATUS_CODE_UNLOCKED,
+    STATUS_CODE_UNKNOWN
+} DA_STATUS_CODE;
+
+typedef enum {
+    AUTH_FLAG_PASSWORD = 0x1 << 0,
+    AUTH_FLAG_FINGERPRINT = 0x1 << 1,
+    AUTH_FLAG_FACE = 0x1 << 2,
+    AUTH_FLAG_AD = 0x1 << 3,
+    AUTH_FLAG_UKEY = 0x1 << 4,
+    AUTH_FLAG_FINGERVEIN = 0x1 << 5,
+    AUTH_FLAG_IRIS = 0x1 << 6,
+    AUTH_FLAG_ALL = -1,
+} DA_AUTH_FLAG;
+
+typedef void (*log_cb)(const char *fmt, ...);
+
+typedef struct _da_limit_info {
+    char type[64];
+    bool locked;
+    int max_tries;
+    int fail_num;
+    char unlock_time[64];
+    int flag;
+    int unlock_secs;
+} da_limit_info;
+
+typedef struct _da_factor_info {
+    int auth_type;
+    int priority;
+    int input_type;
+    bool required;
+} da_factor_info;
+
+typedef bool (*signal_limit_updated_cb)(void *userdata, da_limit_info *dli, int dli_num);
+typedef bool (*signal_status_cb)(void *userdata,
+                                 DA_AUTH_FLAG flag,
+                                 DA_STATUS_CODE status,
+                                 char *msg);
+
+typedef struct _auth_proxy da_proxy;
+
+// if it is used, it needs to be freed
+typedef struct _da_error {
+    int code;
+    char *msg;
+} da_error;
+
+void da_error_free(da_error *err);
+
+// init, create com.deepin.daemon.Authenticate proxy
+int da_set_log_callback(da_proxy *proxy, log_cb cb);
+
+da_proxy *da_dbus_proxy_new();
+
+void da_dbus_proxy_free(da_proxy *proxy);
+
+// create session, create com.deepin.daemon.Authenticate.session proxy
+int da_create_authenticate(da_proxy *proxy,
+                           const char *username,
+                           int flags,
+                           int app_type,
+                           da_error **err);
+
+int da_quit_authenticate(da_proxy *proxy, da_error **err); // session method
+
+// com.deepin.daemon.Authenticate method
+int da_get_limits(da_proxy *proxy,
+                  const char *username,
+                  da_limit_info **limits,
+                  int *limit_len,
+                  da_error **err);
+
+int da_pre_one_key_login(da_proxy *proxy, int flag, char *result, int result_len, da_error **err);
+
+// com.deepin.daemon.Authenticate property
+int da_prop_get_framework_state(da_proxy *proxy, int *result);
+
+int da_prop_get_supported_flags(da_proxy *proxy, int *result);
+
+// com.deepin.daemon.Authenticate signal
+int da_signal_connect_limit_updated(da_proxy *proxy, signal_limit_updated_cb cb, void *userdata);
+
+// after da_create_authenticate, com.deepin.daemon.Authenticate.Session method
+int da_session_set_token(da_proxy *proxy,
+                         const int auth_type,
+                         const char *password,
+                         da_error **err);
+
+int da_session_end(da_proxy *proxy, int flag, int *out_failNum, da_error **err);
+
+int da_session_start(da_proxy *proxy, int flag, int timeout, int *failNum, da_error **err);
+
+// com.deepin.daemon.Authenticate property
+int da_prop_get_is_MFA(da_proxy *proxy, bool *result);
+
+int da_prop_get_prompt(da_proxy *proxy, char *result, int result_len);
+
+int da_prop_get_factors_info(da_proxy *proxy, da_factor_info **result, int *factor_info_len);
+
+// com.deepin.daemon.Authenticate signal
+int da_session_signal_connect_status(da_proxy *proxy, signal_status_cb cb, void *userdata);
+
+bool is_valid_auth_flag(int auth_flag);
+
+da_limit_info *da_get_auth_limit_info(da_limit_info *dli, int dli_num, DA_AUTH_FLAG auth_flag);
+
+G_END_DECLS
+
+#ifdef __cplusplus
+}
+#endif
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.Session.c
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.Session.c
@@ -0,0 +1,3676 @@
+/*
+ * Generated by gdbus-codegen 2.58.3 from com.deepin.daemon.Authenticate.Session.xml. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "com.deepin.daemon.Authenticate.Session.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  gboolean use_gvariant;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface com.deepin.daemon.Authenticate.Session
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:ComDeepinDaemonAuthenticateSession
+ * @title: ComDeepinDaemonAuthenticateSession
+ * @short_description: Generated C code for the com.deepin.daemon.Authenticate.Session D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for com.deepin.daemon.Authenticate.Session ---- */
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_encryptType =
+{
+  {
+    -1,
+    (gchar *) "encryptType",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_encryptMethod =
+{
+  {
+    -1,
+    (gchar *) "encryptMethod",
+    (gchar *) "ai",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_encryptType.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_encryptMethod.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_encType =
+{
+  {
+    -1,
+    (gchar *) "encType",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_encMethod =
+{
+  {
+    -1,
+    (gchar *) "encMethod",
+    (gchar *) "ai",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_pubKey =
+{
+  {
+    -1,
+    (gchar *) "pubKey",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_encType.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_encMethod.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_pubKey.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_encrypt_key =
+{
+  {
+    -1,
+    (gchar *) "EncryptKey",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_encrypt_key_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-encrypt-key",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_end_IN_ARG_flag =
+{
+  {
+    -1,
+    (gchar *) "flag",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_end_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_end_IN_ARG_flag.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_end_OUT_ARG_failNum =
+{
+  {
+    -1,
+    (gchar *) "failNum",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_end_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_end_OUT_ARG_failNum.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_end =
+{
+  {
+    -1,
+    (gchar *) "End",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_end_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_end_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-end",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_get_result_OUT_ARG_result =
+{
+  {
+    -1,
+    (gchar *) "result",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_get_result_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_get_result_OUT_ARG_result.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_get_result =
+{
+  {
+    -1,
+    (gchar *) "GetResult",
+    NULL,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_get_result_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-result",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_privileges_disable =
+{
+  {
+    -1,
+    (gchar *) "PrivilegesDisable",
+    NULL,
+    NULL,
+    NULL
+  },
+  "handle-privileges-disable",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_privileges_enable_IN_ARG_masterPath =
+{
+  {
+    -1,
+    (gchar *) "masterPath",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_privileges_enable_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_privileges_enable_IN_ARG_masterPath.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_privileges_enable_OUT_ARG_enabled =
+{
+  {
+    -1,
+    (gchar *) "enabled",
+    (gchar *) "b",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_privileges_enable_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_privileges_enable_OUT_ARG_enabled.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_privileges_enable =
+{
+  {
+    -1,
+    (gchar *) "PrivilegesEnable",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_privileges_enable_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_privileges_enable_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-privileges-enable",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_quit =
+{
+  {
+    -1,
+    (gchar *) "Quit",
+    NULL,
+    NULL,
+    NULL
+  },
+  "handle-quit",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_set_quit_flag_IN_ARG_method =
+{
+  {
+    -1,
+    (gchar *) "method",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_set_quit_flag_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_set_quit_flag_IN_ARG_method.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_set_quit_flag =
+{
+  {
+    -1,
+    (gchar *) "SetQuitFlag",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_set_quit_flag_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-set-quit-flag",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_flag =
+{
+  {
+    -1,
+    (gchar *) "flag",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_token =
+{
+  {
+    -1,
+    (gchar *) "token",
+    (gchar *) "ay",
+    NULL
+  },
+  TRUE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_flag.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_token.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_set_token =
+{
+  {
+    -1,
+    (gchar *) "SetToken",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_set_token_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-set-token",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_flag =
+{
+  {
+    -1,
+    (gchar *) "flag",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_timeout =
+{
+  {
+    -1,
+    (gchar *) "timeout",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_flag.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_timeout.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_start_OUT_ARG_failNum =
+{
+  {
+    -1,
+    (gchar *) "failNum",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_start_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_start_OUT_ARG_failNum.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_start =
+{
+  {
+    -1,
+    (gchar *) "Start",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_start_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_start_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-start",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_method_info_set_symmetric_key_IN_ARG_key =
+{
+  {
+    -1,
+    (gchar *) "key",
+    (gchar *) "ay",
+    NULL
+  },
+  TRUE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_method_info_set_symmetric_key_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_set_symmetric_key_IN_ARG_key.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_session_method_info_set_symmetric_key =
+{
+  {
+    -1,
+    (gchar *) "SetSymmetricKey",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_method_info_set_symmetric_key_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-set-symmetric-key",
+  FALSE
+};
+
+static const GDBusMethodInfo * const _com_deepin_daemon_authenticate_session_method_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_method_info_encrypt_key.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_end.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_get_result.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_privileges_disable.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_privileges_enable.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_quit.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_set_quit_flag.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_set_token.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_start.parent_struct,
+  &_com_deepin_daemon_authenticate_session_method_info_set_symmetric_key.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_signal_info_status_ARG_flag =
+{
+  {
+    -1,
+    (gchar *) "flag",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_signal_info_status_ARG_status =
+{
+  {
+    -1,
+    (gchar *) "status",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_session_signal_info_status_ARG_msg =
+{
+  {
+    -1,
+    (gchar *) "msg",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_session_signal_info_status_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_signal_info_status_ARG_flag.parent_struct,
+  &_com_deepin_daemon_authenticate_session_signal_info_status_ARG_status.parent_struct,
+  &_com_deepin_daemon_authenticate_session_signal_info_status_ARG_msg.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _com_deepin_daemon_authenticate_session_signal_info_status =
+{
+  {
+    -1,
+    (gchar *) "Status",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_session_signal_info_status_ARG_pointers,
+    NULL
+  },
+  "status"
+};
+
+static const GDBusSignalInfo * const _com_deepin_daemon_authenticate_session_signal_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_signal_info_status.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_is_mfa =
+{
+  {
+    -1,
+    (gchar *) "IsMFA",
+    (gchar *) "b",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "is-mfa",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_prompt =
+{
+  {
+    -1,
+    (gchar *) "Prompt",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "prompt",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_factors_info =
+{
+  {
+    -1,
+    (gchar *) "FactorsInfo",
+    (gchar *) "a(iiib)",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "factors-info",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_username =
+{
+  {
+    -1,
+    (gchar *) "Username",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "username",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_pinlen =
+{
+  {
+    -1,
+    (gchar *) "PINLen",
+    (gchar *) "i",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "pinlen",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_session_property_info_prg_path =
+{
+  {
+    -1,
+    (gchar *) "PrgPath",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "prg-path",
+  FALSE
+};
+
+static const GDBusPropertyInfo * const _com_deepin_daemon_authenticate_session_property_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_session_property_info_is_mfa.parent_struct,
+  &_com_deepin_daemon_authenticate_session_property_info_prompt.parent_struct,
+  &_com_deepin_daemon_authenticate_session_property_info_factors_info.parent_struct,
+  &_com_deepin_daemon_authenticate_session_property_info_username.parent_struct,
+  &_com_deepin_daemon_authenticate_session_property_info_pinlen.parent_struct,
+  &_com_deepin_daemon_authenticate_session_property_info_prg_path.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _com_deepin_daemon_authenticate_session_interface_info =
+{
+  {
+    -1,
+    (gchar *) "com.deepin.daemon.Authenticate.Session",
+    (GDBusMethodInfo **) &_com_deepin_daemon_authenticate_session_method_info_pointers,
+    (GDBusSignalInfo **) &_com_deepin_daemon_authenticate_session_signal_info_pointers,
+    (GDBusPropertyInfo **) &_com_deepin_daemon_authenticate_session_property_info_pointers,
+    NULL
+  },
+  "com-deepin-daemon-authenticate-session",
+};
+
+
+/**
+ * com_deepin_daemon_authenticate_session_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+com_deepin_daemon_authenticate_session_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #ComDeepinDaemonAuthenticateSession interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+com_deepin_daemon_authenticate_session_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "is-mfa");
+  g_object_class_override_property (klass, property_id_begin++, "prompt");
+  g_object_class_override_property (klass, property_id_begin++, "factors-info");
+  g_object_class_override_property (klass, property_id_begin++, "username");
+  g_object_class_override_property (klass, property_id_begin++, "pinlen");
+  g_object_class_override_property (klass, property_id_begin++, "prg-path");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * ComDeepinDaemonAuthenticateSession:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link>.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateSessionIface:
+ * @parent_iface: The parent interface.
+ * @handle_encrypt_key: Handler for the #ComDeepinDaemonAuthenticateSession::handle-encrypt-key signal.
+ * @handle_end: Handler for the #ComDeepinDaemonAuthenticateSession::handle-end signal.
+ * @handle_get_result: Handler for the #ComDeepinDaemonAuthenticateSession::handle-get-result signal.
+ * @handle_privileges_disable: Handler for the #ComDeepinDaemonAuthenticateSession::handle-privileges-disable signal.
+ * @handle_privileges_enable: Handler for the #ComDeepinDaemonAuthenticateSession::handle-privileges-enable signal.
+ * @handle_quit: Handler for the #ComDeepinDaemonAuthenticateSession::handle-quit signal.
+ * @handle_set_quit_flag: Handler for the #ComDeepinDaemonAuthenticateSession::handle-set-quit-flag signal.
+ * @handle_set_symmetric_key: Handler for the #ComDeepinDaemonAuthenticateSession::handle-set-symmetric-key signal.
+ * @handle_set_token: Handler for the #ComDeepinDaemonAuthenticateSession::handle-set-token signal.
+ * @handle_start: Handler for the #ComDeepinDaemonAuthenticateSession::handle-start signal.
+ * @get_factors_info: Getter for the #ComDeepinDaemonAuthenticateSession:factors-info property.
+ * @get_is_mfa: Getter for the #ComDeepinDaemonAuthenticateSession:is-mfa property.
+ * @get_pinlen: Getter for the #ComDeepinDaemonAuthenticateSession:pinlen property.
+ * @get_prg_path: Getter for the #ComDeepinDaemonAuthenticateSession:prg-path property.
+ * @get_prompt: Getter for the #ComDeepinDaemonAuthenticateSession:prompt property.
+ * @get_username: Getter for the #ComDeepinDaemonAuthenticateSession:username property.
+ * @status: Handler for the #ComDeepinDaemonAuthenticateSession::status signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link>.
+ */
+
+typedef ComDeepinDaemonAuthenticateSessionIface ComDeepinDaemonAuthenticateSessionInterface;
+G_DEFINE_INTERFACE (ComDeepinDaemonAuthenticateSession, com_deepin_daemon_authenticate_session, G_TYPE_OBJECT)
+
+static void
+com_deepin_daemon_authenticate_session_default_init (ComDeepinDaemonAuthenticateSessionIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-encrypt-key:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_encryptType: Argument passed by remote caller.
+   * @arg_encryptMethod: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.EncryptKey">EncryptKey()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_encrypt_key() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-encrypt-key",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_encrypt_key),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT, G_TYPE_VARIANT);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-end:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_flag: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.End">End()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_end() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-end",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_end),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-get-result:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.GetResult">GetResult()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_get_result() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-result",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_get_result),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-privileges-disable:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesDisable">PrivilegesDisable()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_privileges_disable() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-privileges-disable",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_privileges_disable),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-privileges-enable:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_masterPath: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesEnable">PrivilegesEnable()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_privileges_enable() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-privileges-enable",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_privileges_enable),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-quit:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Quit">Quit()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_quit() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-quit",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_quit),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    1,
+    G_TYPE_DBUS_METHOD_INVOCATION);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-set-quit-flag:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_method: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetQuitFlag">SetQuitFlag()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_set_quit_flag() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-quit-flag",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_set_quit_flag),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-set-token:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_flag: Argument passed by remote caller.
+   * @arg_token: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetToken">SetToken()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_set_token() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-token",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_set_token),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT, G_TYPE_VARIANT);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-start:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_flag: Argument passed by remote caller.
+   * @arg_timeout: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Start">Start()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_start() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-start",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_start),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    3,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT, G_TYPE_INT);
+
+  /**
+   * ComDeepinDaemonAuthenticateSession::handle-set-symmetric-key:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_key: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetSymmetricKey">SetSymmetricKey()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_session_complete_set_symmetric_key() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-set-symmetric-key",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, handle_set_symmetric_key),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * ComDeepinDaemonAuthenticateSession::status:
+   * @object: A #ComDeepinDaemonAuthenticateSession.
+   * @arg_flag: Argument.
+   * @arg_status: Argument.
+   * @arg_msg: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-deepin-daemon-Authenticate-Session.Status">"Status"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("status",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateSessionIface, status),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    3, G_TYPE_INT, G_TYPE_INT, G_TYPE_STRING);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * ComDeepinDaemonAuthenticateSession:is-mfa:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.IsMFA">"IsMFA"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_boolean ("is-mfa", "IsMFA", "IsMFA", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticateSession:prompt:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Prompt">"Prompt"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("prompt", "Prompt", "Prompt", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticateSession:factors-info:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.FactorsInfo">"FactorsInfo"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_variant ("factors-info", "FactorsInfo", "FactorsInfo", G_VARIANT_TYPE ("a(iiib)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticateSession:username:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Username">"Username"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("username", "Username", "Username", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticateSession:pinlen:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PINLen">"PINLen"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int ("pinlen", "PINLen", "PINLen", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticateSession:prg-path:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PrgPath">"PrgPath"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("prg-path", "PrgPath", "PrgPath", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_is_mfa: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.IsMFA">"IsMFA"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gboolean 
+com_deepin_daemon_authenticate_session_get_is_mfa (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_is_mfa (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_is_mfa: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.IsMFA">"IsMFA"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_is_mfa (ComDeepinDaemonAuthenticateSession *object, gboolean value)
+{
+  g_object_set (G_OBJECT (object), "is-mfa", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_prompt: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Prompt">"Prompt"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use com_deepin_daemon_authenticate_session_dup_prompt() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+com_deepin_daemon_authenticate_session_get_prompt (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_prompt (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_dup_prompt: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Prompt">"Prompt"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+com_deepin_daemon_authenticate_session_dup_prompt (ComDeepinDaemonAuthenticateSession *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "prompt", &value, NULL);
+  return value;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_prompt: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Prompt">"Prompt"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_prompt (ComDeepinDaemonAuthenticateSession *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "prompt", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_factors_info: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.FactorsInfo">"FactorsInfo"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use com_deepin_daemon_authenticate_session_dup_factors_info() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+GVariant *
+com_deepin_daemon_authenticate_session_get_factors_info (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_factors_info (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_dup_factors_info: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.FactorsInfo">"FactorsInfo"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
+ */
+GVariant *
+com_deepin_daemon_authenticate_session_dup_factors_info (ComDeepinDaemonAuthenticateSession *object)
+{
+  GVariant *value;
+  g_object_get (G_OBJECT (object), "factors-info", &value, NULL);
+  return value;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_factors_info: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.FactorsInfo">"FactorsInfo"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_factors_info (ComDeepinDaemonAuthenticateSession *object, GVariant *value)
+{
+  g_object_set (G_OBJECT (object), "factors-info", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_username: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Username">"Username"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use com_deepin_daemon_authenticate_session_dup_username() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+com_deepin_daemon_authenticate_session_get_username (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_username (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_dup_username: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Username">"Username"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+com_deepin_daemon_authenticate_session_dup_username (ComDeepinDaemonAuthenticateSession *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "username", &value, NULL);
+  return value;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_username: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.Username">"Username"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_username (ComDeepinDaemonAuthenticateSession *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "username", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_pinlen: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PINLen">"PINLen"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint 
+com_deepin_daemon_authenticate_session_get_pinlen (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_pinlen (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_pinlen: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PINLen">"PINLen"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_pinlen (ComDeepinDaemonAuthenticateSession *object, gint value)
+{
+  g_object_set (G_OBJECT (object), "pinlen", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_get_prg_path: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PrgPath">"PrgPath"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use com_deepin_daemon_authenticate_session_dup_prg_path() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+com_deepin_daemon_authenticate_session_get_prg_path (ComDeepinDaemonAuthenticateSession *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE (object)->get_prg_path (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_dup_prg_path: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PrgPath">"PrgPath"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+com_deepin_daemon_authenticate_session_dup_prg_path (ComDeepinDaemonAuthenticateSession *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "prg-path", &value, NULL);
+  return value;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_set_prg_path: (skip)
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate-Session.PrgPath">"PrgPath"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_session_set_prg_path (ComDeepinDaemonAuthenticateSession *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "prg-path", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_emit_status:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @arg_flag: Argument to pass with the signal.
+ * @arg_status: Argument to pass with the signal.
+ * @arg_msg: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-com-deepin-daemon-Authenticate-Session.Status">"Status"</link> D-Bus signal.
+ */
+void
+com_deepin_daemon_authenticate_session_emit_status (
+    ComDeepinDaemonAuthenticateSession *object,
+    gint arg_flag,
+    gint arg_status,
+    const gchar *arg_msg)
+{
+  g_signal_emit_by_name (object, "status", arg_flag, arg_status, arg_msg);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_encrypt_key:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_encryptType: Argument to pass with the method invocation.
+ * @arg_encryptMethod: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.EncryptKey">EncryptKey()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_encrypt_key_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_encrypt_key_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_encrypt_key (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_encryptType,
+    GVariant *arg_encryptMethod,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "EncryptKey",
+    g_variant_new ("(i@ai)",
+                   arg_encryptType,
+                   arg_encryptMethod),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_encrypt_key_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_encType: (out): Return location for return parameter or %NULL to ignore.
+ * @out_encMethod: (out): Return location for return parameter or %NULL to ignore.
+ * @out_pubKey: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_encrypt_key().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_encrypt_key().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_encrypt_key_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_encType,
+    GVariant **out_encMethod,
+    gchar **out_pubKey,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i@ais)",
+                 out_encType,
+                 out_encMethod,
+                 out_pubKey);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_encrypt_key_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_encryptType: Argument to pass with the method invocation.
+ * @arg_encryptMethod: Argument to pass with the method invocation.
+ * @out_encType: (out): Return location for return parameter or %NULL to ignore.
+ * @out_encMethod: (out): Return location for return parameter or %NULL to ignore.
+ * @out_pubKey: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.EncryptKey">EncryptKey()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_encrypt_key() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_encrypt_key_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_encryptType,
+    GVariant *arg_encryptMethod,
+    gint *out_encType,
+    GVariant **out_encMethod,
+    gchar **out_pubKey,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "EncryptKey",
+    g_variant_new ("(i@ai)",
+                   arg_encryptType,
+                   arg_encryptMethod),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i@ais)",
+                 out_encType,
+                 out_encMethod,
+                 out_pubKey);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_end:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.End">End()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_end_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_end_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_end (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "End",
+    g_variant_new ("(i)",
+                   arg_flag),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_end_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_failNum: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_end().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_end().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_end_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_failNum,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_failNum);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_end_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @out_failNum: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.End">End()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_end() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_end_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint *out_failNum,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "End",
+    g_variant_new ("(i)",
+                   arg_flag),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_failNum);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_get_result:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.GetResult">GetResult()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_get_result_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_get_result_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_get_result (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetResult",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_get_result_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_result: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_get_result().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_get_result().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_get_result_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_result,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_get_result_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_result: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.GetResult">GetResult()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_get_result() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_get_result_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_result,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetResult",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_disable:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesDisable">PrivilegesDisable()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_privileges_disable_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_privileges_disable_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_privileges_disable (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "PrivilegesDisable",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_disable_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_privileges_disable().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_privileges_disable().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_privileges_disable_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_disable_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesDisable">PrivilegesDisable()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_privileges_disable() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_privileges_disable_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "PrivilegesDisable",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_enable:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_masterPath: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesEnable">PrivilegesEnable()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_privileges_enable_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_privileges_enable_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_privileges_enable (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    const gchar *arg_masterPath,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "PrivilegesEnable",
+    g_variant_new ("(s)",
+                   arg_masterPath),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_enable_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_enabled: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_privileges_enable().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_privileges_enable().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_privileges_enable_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gboolean *out_enabled,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(b)",
+                 out_enabled);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_privileges_enable_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_masterPath: Argument to pass with the method invocation.
+ * @out_enabled: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesEnable">PrivilegesEnable()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_privileges_enable() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_privileges_enable_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    const gchar *arg_masterPath,
+    gboolean *out_enabled,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "PrivilegesEnable",
+    g_variant_new ("(s)",
+                   arg_masterPath),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(b)",
+                 out_enabled);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_quit:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Quit">Quit()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_quit_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_quit_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_quit (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Quit",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_quit_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_quit().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_quit().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_quit_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_quit_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Quit">Quit()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_quit() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_quit_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Quit",
+    g_variant_new ("()"),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_quit_flag:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_method: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetQuitFlag">SetQuitFlag()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_set_quit_flag_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_quit_flag_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_set_quit_flag (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_method,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetQuitFlag",
+    g_variant_new ("(i)",
+                   arg_method),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_quit_flag_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_set_quit_flag().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_set_quit_flag().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_quit_flag_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_quit_flag_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_method: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetQuitFlag">SetQuitFlag()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_quit_flag() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_quit_flag_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_method,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetQuitFlag",
+    g_variant_new ("(i)",
+                   arg_method),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_token:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @arg_token: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetToken">SetToken()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_set_token_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_token_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_set_token (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GVariant *arg_token,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetToken",
+    g_variant_new ("(i@ay)",
+                   arg_flag,
+                   arg_token),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_token_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_set_token().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_set_token().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_token_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_token_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @arg_token: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetToken">SetToken()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_token() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_token_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GVariant *arg_token,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetToken",
+    g_variant_new ("(i@ay)",
+                   arg_flag,
+                   arg_token),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_start:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @arg_timeout: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Start">Start()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_start_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_start_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_start (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint arg_timeout,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Start",
+    g_variant_new ("(ii)",
+                   arg_flag,
+                   arg_timeout),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_start_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @out_failNum: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_start().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_start().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_start_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_failNum,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_failNum);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_start_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @arg_timeout: Argument to pass with the method invocation.
+ * @out_failNum: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Start">Start()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_start() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_start_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint arg_timeout,
+    gint *out_failNum,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Start",
+    g_variant_new ("(ii)",
+                   arg_flag,
+                   arg_timeout),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(i)",
+                 out_failNum);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_symmetric_key:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_key: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetSymmetricKey">SetSymmetricKey()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_call_set_symmetric_key_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_symmetric_key_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_session_call_set_symmetric_key (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GVariant *arg_key,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "SetSymmetricKey",
+    g_variant_new ("(@ay)",
+                   arg_key),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_symmetric_key_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_call_set_symmetric_key().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_call_set_symmetric_key().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_symmetric_key_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_call_set_symmetric_key_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateSessionProxy.
+ * @arg_key: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetSymmetricKey">SetSymmetricKey()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_call_set_symmetric_key() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_session_call_set_symmetric_key_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GVariant *arg_key,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "SetSymmetricKey",
+    g_variant_new ("(@ay)",
+                   arg_key),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_encrypt_key:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @encType: Parameter to return.
+ * @encMethod: Parameter to return.
+ * @pubKey: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.EncryptKey">EncryptKey()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_encrypt_key (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint encType,
+    GVariant *encMethod,
+    const gchar *pubKey)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(i@ais)",
+                   encType,
+                   encMethod,
+                   pubKey));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_end:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @failNum: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.End">End()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_end (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint failNum)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(i)",
+                   failNum));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_get_result:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @result: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.GetResult">GetResult()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_get_result (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint result)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(i)",
+                   result));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_privileges_disable:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesDisable">PrivilegesDisable()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_privileges_disable (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_privileges_enable:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @enabled: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.PrivilegesEnable">PrivilegesEnable()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_privileges_enable (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gboolean enabled)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(b)",
+                   enabled));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_quit:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Quit">Quit()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_quit (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_set_quit_flag:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetQuitFlag">SetQuitFlag()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_set_quit_flag (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_set_token:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetToken">SetToken()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_set_token (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_start:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @failNum: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.Start">Start()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_start (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint failNum)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(i)",
+                   failNum));
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_complete_set_symmetric_key:
+ * @object: A #ComDeepinDaemonAuthenticateSession.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate-Session.SetSymmetricKey">SetSymmetricKey()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_session_complete_set_symmetric_key (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ComDeepinDaemonAuthenticateSessionProxy:
+ *
+ * The #ComDeepinDaemonAuthenticateSessionProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateSessionProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ComDeepinDaemonAuthenticateSessionProxy.
+ */
+
+struct _ComDeepinDaemonAuthenticateSessionProxyPrivate
+{
+  GData *qdata;
+};
+
+static void com_deepin_daemon_authenticate_session_proxy_iface_init (ComDeepinDaemonAuthenticateSessionIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSessionProxy, com_deepin_daemon_authenticate_session_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (ComDeepinDaemonAuthenticateSessionProxy)
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, com_deepin_daemon_authenticate_session_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSessionProxy, com_deepin_daemon_authenticate_session_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, com_deepin_daemon_authenticate_session_proxy_iface_init))
+
+#endif
+static void
+com_deepin_daemon_authenticate_session_proxy_finalize (GObject *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (com_deepin_daemon_authenticate_session_proxy_parent_class)->finalize (object);
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 6);
+  info = (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_session_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface com.deepin.daemon.Authenticate.Session: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 6);
+  info = (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_session_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "com.deepin.daemon.Authenticate.Session", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) com_deepin_daemon_authenticate_session_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static gboolean 
+com_deepin_daemon_authenticate_session_proxy_get_is_mfa (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  gboolean value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IsMFA");
+  if (variant != NULL)
+    {
+      value = g_variant_get_boolean (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_proxy_get_prompt (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Prompt");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static GVariant *
+com_deepin_daemon_authenticate_session_proxy_get_factors_info (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  GVariant *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FactorsInfo");
+  value = variant;
+  if (variant != NULL)
+    g_variant_unref (variant);
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_proxy_get_username (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Username");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_session_proxy_get_pinlen (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  gint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PINLen");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_proxy_get_prg_path (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PrgPath");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_init (ComDeepinDaemonAuthenticateSessionProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = com_deepin_daemon_authenticate_session_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, ComDeepinDaemonAuthenticateSessionProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), com_deepin_daemon_authenticate_session_interface_info ());
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_class_init (ComDeepinDaemonAuthenticateSessionProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = com_deepin_daemon_authenticate_session_proxy_finalize;
+  gobject_class->get_property = com_deepin_daemon_authenticate_session_proxy_get_property;
+  gobject_class->set_property = com_deepin_daemon_authenticate_session_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = com_deepin_daemon_authenticate_session_proxy_g_signal;
+  proxy_class->g_properties_changed = com_deepin_daemon_authenticate_session_proxy_g_properties_changed;
+
+  com_deepin_daemon_authenticate_session_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ComDeepinDaemonAuthenticateSessionProxyPrivate));
+#endif
+}
+
+static void
+com_deepin_daemon_authenticate_session_proxy_iface_init (ComDeepinDaemonAuthenticateSessionIface *iface)
+{
+  iface->get_is_mfa = com_deepin_daemon_authenticate_session_proxy_get_is_mfa;
+  iface->get_prompt = com_deepin_daemon_authenticate_session_proxy_get_prompt;
+  iface->get_factors_info = com_deepin_daemon_authenticate_session_proxy_get_factors_info;
+  iface->get_username = com_deepin_daemon_authenticate_session_proxy_get_username;
+  iface->get_pinlen = com_deepin_daemon_authenticate_session_proxy_get_pinlen;
+  iface->get_prg_path = com_deepin_daemon_authenticate_session_proxy_get_prg_path;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_proxy_new_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+com_deepin_daemon_authenticate_session_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate.Session", NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_proxy_new().
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSessionProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticateSession *
+com_deepin_daemon_authenticate_session_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (ret);
+  else
+    return NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSessionProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticateSession *
+com_deepin_daemon_authenticate_session_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate.Session", NULL);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like com_deepin_daemon_authenticate_session_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_session_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_session_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+com_deepin_daemon_authenticate_session_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate.Session", NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_session_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_session_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSessionProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticateSession *
+com_deepin_daemon_authenticate_session_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (ret);
+  else
+    return NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like com_deepin_daemon_authenticate_session_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_session_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSessionProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticateSession *
+com_deepin_daemon_authenticate_session_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate.Session", NULL);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ComDeepinDaemonAuthenticateSessionSkeleton:
+ *
+ * The #ComDeepinDaemonAuthenticateSessionSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateSessionSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ComDeepinDaemonAuthenticateSessionSkeleton.
+ */
+
+struct _ComDeepinDaemonAuthenticateSessionSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_com_deepin_daemon_authenticate_session_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_com_deepin_daemon_authenticate_session_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_com_deepin_daemon_authenticate_session_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_session_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _com_deepin_daemon_authenticate_session_skeleton_vtable =
+{
+  _com_deepin_daemon_authenticate_session_skeleton_handle_method_call,
+  _com_deepin_daemon_authenticate_session_skeleton_handle_get_property,
+  _com_deepin_daemon_authenticate_session_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return com_deepin_daemon_authenticate_session_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_com_deepin_daemon_authenticate_session_skeleton_vtable;
+}
+
+static GVariant *
+com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_com_deepin_daemon_authenticate_session_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _com_deepin_daemon_authenticate_session_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _com_deepin_daemon_authenticate_session_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _com_deepin_daemon_authenticate_session_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.deepin.daemon.Authenticate.Session", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _com_deepin_daemon_authenticate_session_emit_changed (gpointer user_data);
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _com_deepin_daemon_authenticate_session_emit_changed (skeleton);
+}
+
+static void
+_com_deepin_daemon_authenticate_session_on_signal_status (
+    ComDeepinDaemonAuthenticateSession *object,
+    gint arg_flag,
+    gint arg_status,
+    const gchar *arg_msg)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(iis)",
+                   arg_flag,
+                   arg_status,
+                   arg_msg));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.deepin.daemon.Authenticate.Session", "Status",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void com_deepin_daemon_authenticate_session_skeleton_iface_init (ComDeepinDaemonAuthenticateSessionIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSessionSkeleton, com_deepin_daemon_authenticate_session_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (ComDeepinDaemonAuthenticateSessionSkeleton)
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, com_deepin_daemon_authenticate_session_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSessionSkeleton, com_deepin_daemon_authenticate_session_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, com_deepin_daemon_authenticate_session_skeleton_iface_init))
+
+#endif
+static void
+com_deepin_daemon_authenticate_session_skeleton_finalize (GObject *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  guint n;
+  for (n = 0; n < 6; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (com_deepin_daemon_authenticate_session_skeleton_parent_class)->finalize (object);
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 6);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_com_deepin_daemon_authenticate_session_emit_changed (gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "com.deepin.daemon.Authenticate.Session",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_com_deepin_daemon_authenticate_session_schedule_emit_changed (ComDeepinDaemonAuthenticateSessionSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _com_deepin_daemon_authenticate_session_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _com_deepin_daemon_authenticate_session_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 6);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
+        _com_deepin_daemon_authenticate_session_schedule_emit_changed (skeleton, (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_session_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_init (ComDeepinDaemonAuthenticateSessionSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = com_deepin_daemon_authenticate_session_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON, ComDeepinDaemonAuthenticateSessionSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 6);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
+  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[2], G_TYPE_VARIANT);
+  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[4], G_TYPE_INT);
+  g_value_init (&skeleton->priv->properties[5], G_TYPE_STRING);
+}
+
+static gboolean 
+com_deepin_daemon_authenticate_session_skeleton_get_is_mfa (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  gboolean value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_skeleton_get_prompt (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[1]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static GVariant *
+com_deepin_daemon_authenticate_session_skeleton_get_factors_info (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  GVariant *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_variant (&(skeleton->priv->properties[2]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_skeleton_get_username (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[3]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_session_skeleton_get_pinlen (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  gint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int (&(skeleton->priv->properties[4]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_session_skeleton_get_prg_path (ComDeepinDaemonAuthenticateSession *object)
+{
+  ComDeepinDaemonAuthenticateSessionSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[5]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_class_init (ComDeepinDaemonAuthenticateSessionSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = com_deepin_daemon_authenticate_session_skeleton_finalize;
+  gobject_class->get_property = com_deepin_daemon_authenticate_session_skeleton_get_property;
+  gobject_class->set_property = com_deepin_daemon_authenticate_session_skeleton_set_property;
+  gobject_class->notify       = com_deepin_daemon_authenticate_session_skeleton_notify;
+
+
+  com_deepin_daemon_authenticate_session_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = com_deepin_daemon_authenticate_session_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = com_deepin_daemon_authenticate_session_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ComDeepinDaemonAuthenticateSessionSkeletonPrivate));
+#endif
+}
+
+static void
+com_deepin_daemon_authenticate_session_skeleton_iface_init (ComDeepinDaemonAuthenticateSessionIface *iface)
+{
+  iface->status = _com_deepin_daemon_authenticate_session_on_signal_status;
+  iface->get_is_mfa = com_deepin_daemon_authenticate_session_skeleton_get_is_mfa;
+  iface->get_prompt = com_deepin_daemon_authenticate_session_skeleton_get_prompt;
+  iface->get_factors_info = com_deepin_daemon_authenticate_session_skeleton_get_factors_info;
+  iface->get_username = com_deepin_daemon_authenticate_session_skeleton_get_username;
+  iface->get_pinlen = com_deepin_daemon_authenticate_session_skeleton_get_pinlen;
+  iface->get_prg_path = com_deepin_daemon_authenticate_session_skeleton_get_prg_path;
+}
+
+/**
+ * com_deepin_daemon_authenticate_session_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate-Session.top_of_page">com.deepin.daemon.Authenticate.Session</link>.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSessionSkeleton): The skeleton object.
+ */
+ComDeepinDaemonAuthenticateSession *
+com_deepin_daemon_authenticate_session_skeleton_new (void)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (g_object_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON, NULL));
+}
+
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.Session.h
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.Session.h
@@ -0,0 +1,496 @@
+/*
+ * Generated by gdbus-codegen 2.58.3 from com.deepin.daemon.Authenticate.Session.xml. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from.
+ */
+
+#ifndef __COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_H__
+#define __COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for com.deepin.daemon.Authenticate.Session */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION (com_deepin_daemon_authenticate_session_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, ComDeepinDaemonAuthenticateSession))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION, ComDeepinDaemonAuthenticateSessionIface))
+
+struct _ComDeepinDaemonAuthenticateSession;
+typedef struct _ComDeepinDaemonAuthenticateSession ComDeepinDaemonAuthenticateSession;
+typedef struct _ComDeepinDaemonAuthenticateSessionIface ComDeepinDaemonAuthenticateSessionIface;
+
+struct _ComDeepinDaemonAuthenticateSessionIface
+{
+  GTypeInterface parent_iface;
+
+
+
+  gboolean (*handle_encrypt_key) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_encryptType,
+    GVariant *arg_encryptMethod);
+
+  gboolean (*handle_end) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_flag);
+
+  gboolean (*handle_get_result) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_privileges_disable) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_privileges_enable) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_masterPath);
+
+  gboolean (*handle_quit) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+  gboolean (*handle_set_quit_flag) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_method);
+
+  gboolean (*handle_set_symmetric_key) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    GVariant *arg_key);
+
+  gboolean (*handle_set_token) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_flag,
+    GVariant *arg_token);
+
+  gboolean (*handle_start) (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_flag,
+    gint arg_timeout);
+
+  GVariant * (*get_factors_info) (ComDeepinDaemonAuthenticateSession *object);
+
+  gboolean  (*get_is_mfa) (ComDeepinDaemonAuthenticateSession *object);
+
+  gint  (*get_pinlen) (ComDeepinDaemonAuthenticateSession *object);
+
+  const gchar * (*get_prg_path) (ComDeepinDaemonAuthenticateSession *object);
+
+  const gchar * (*get_prompt) (ComDeepinDaemonAuthenticateSession *object);
+
+  const gchar * (*get_username) (ComDeepinDaemonAuthenticateSession *object);
+
+  void (*status) (
+    ComDeepinDaemonAuthenticateSession *object,
+    gint arg_flag,
+    gint arg_status,
+    const gchar *arg_msg);
+
+};
+
+GType com_deepin_daemon_authenticate_session_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *com_deepin_daemon_authenticate_session_interface_info (void);
+guint com_deepin_daemon_authenticate_session_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void com_deepin_daemon_authenticate_session_complete_encrypt_key (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint encType,
+    GVariant *encMethod,
+    const gchar *pubKey);
+
+void com_deepin_daemon_authenticate_session_complete_end (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint failNum);
+
+void com_deepin_daemon_authenticate_session_complete_get_result (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint result);
+
+void com_deepin_daemon_authenticate_session_complete_privileges_disable (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+void com_deepin_daemon_authenticate_session_complete_privileges_enable (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gboolean enabled);
+
+void com_deepin_daemon_authenticate_session_complete_quit (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+void com_deepin_daemon_authenticate_session_complete_set_quit_flag (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+void com_deepin_daemon_authenticate_session_complete_set_token (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+void com_deepin_daemon_authenticate_session_complete_start (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation,
+    gint failNum);
+
+void com_deepin_daemon_authenticate_session_complete_set_symmetric_key (
+    ComDeepinDaemonAuthenticateSession *object,
+    GDBusMethodInvocation *invocation);
+
+
+
+/* D-Bus signal emissions functions: */
+void com_deepin_daemon_authenticate_session_emit_status (
+    ComDeepinDaemonAuthenticateSession *object,
+    gint arg_flag,
+    gint arg_status,
+    const gchar *arg_msg);
+
+
+
+/* D-Bus method calls: */
+void com_deepin_daemon_authenticate_session_call_encrypt_key (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_encryptType,
+    GVariant *arg_encryptMethod,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_encrypt_key_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_encType,
+    GVariant **out_encMethod,
+    gchar **out_pubKey,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_encrypt_key_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_encryptType,
+    GVariant *arg_encryptMethod,
+    gint *out_encType,
+    GVariant **out_encMethod,
+    gchar **out_pubKey,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_end (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_end_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_failNum,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_end_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint *out_failNum,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_get_result (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_get_result_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_result,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_get_result_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_result,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_privileges_disable (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_privileges_disable_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_privileges_disable_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_privileges_enable (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    const gchar *arg_masterPath,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_privileges_enable_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gboolean *out_enabled,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_privileges_enable_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    const gchar *arg_masterPath,
+    gboolean *out_enabled,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_quit (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_quit_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_quit_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_set_quit_flag (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_method,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_quit_flag_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_quit_flag_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_method,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_set_token (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GVariant *arg_token,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_token_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_token_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    GVariant *arg_token,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_start (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint arg_timeout,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_start_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint *out_failNum,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_start_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    gint arg_flag,
+    gint arg_timeout,
+    gint *out_failNum,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_session_call_set_symmetric_key (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GVariant *arg_key,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_symmetric_key_finish (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_session_call_set_symmetric_key_sync (
+    ComDeepinDaemonAuthenticateSession *proxy,
+    GVariant *arg_key,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+gboolean com_deepin_daemon_authenticate_session_get_is_mfa (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_is_mfa (ComDeepinDaemonAuthenticateSession *object, gboolean value);
+
+const gchar *com_deepin_daemon_authenticate_session_get_prompt (ComDeepinDaemonAuthenticateSession *object);
+gchar *com_deepin_daemon_authenticate_session_dup_prompt (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_prompt (ComDeepinDaemonAuthenticateSession *object, const gchar *value);
+
+GVariant *com_deepin_daemon_authenticate_session_get_factors_info (ComDeepinDaemonAuthenticateSession *object);
+GVariant *com_deepin_daemon_authenticate_session_dup_factors_info (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_factors_info (ComDeepinDaemonAuthenticateSession *object, GVariant *value);
+
+const gchar *com_deepin_daemon_authenticate_session_get_username (ComDeepinDaemonAuthenticateSession *object);
+gchar *com_deepin_daemon_authenticate_session_dup_username (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_username (ComDeepinDaemonAuthenticateSession *object, const gchar *value);
+
+gint com_deepin_daemon_authenticate_session_get_pinlen (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_pinlen (ComDeepinDaemonAuthenticateSession *object, gint value);
+
+const gchar *com_deepin_daemon_authenticate_session_get_prg_path (ComDeepinDaemonAuthenticateSession *object);
+gchar *com_deepin_daemon_authenticate_session_dup_prg_path (ComDeepinDaemonAuthenticateSession *object);
+void com_deepin_daemon_authenticate_session_set_prg_path (ComDeepinDaemonAuthenticateSession *object, const gchar *value);
+
+
+/* ---- */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY (com_deepin_daemon_authenticate_session_proxy_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, ComDeepinDaemonAuthenticateSessionProxy))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, ComDeepinDaemonAuthenticateSessionProxyClass))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY, ComDeepinDaemonAuthenticateSessionProxyClass))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_PROXY))
+
+typedef struct _ComDeepinDaemonAuthenticateSessionProxy ComDeepinDaemonAuthenticateSessionProxy;
+typedef struct _ComDeepinDaemonAuthenticateSessionProxyClass ComDeepinDaemonAuthenticateSessionProxyClass;
+typedef struct _ComDeepinDaemonAuthenticateSessionProxyPrivate ComDeepinDaemonAuthenticateSessionProxyPrivate;
+
+struct _ComDeepinDaemonAuthenticateSessionProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  ComDeepinDaemonAuthenticateSessionProxyPrivate *priv;
+};
+
+struct _ComDeepinDaemonAuthenticateSessionProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType com_deepin_daemon_authenticate_session_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ComDeepinDaemonAuthenticateSessionProxy, g_object_unref)
+#endif
+
+void com_deepin_daemon_authenticate_session_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ComDeepinDaemonAuthenticateSession *com_deepin_daemon_authenticate_session_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ComDeepinDaemonAuthenticateSession *com_deepin_daemon_authenticate_session_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void com_deepin_daemon_authenticate_session_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ComDeepinDaemonAuthenticateSession *com_deepin_daemon_authenticate_session_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ComDeepinDaemonAuthenticateSession *com_deepin_daemon_authenticate_session_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON (com_deepin_daemon_authenticate_session_skeleton_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON, ComDeepinDaemonAuthenticateSessionSkeleton))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON, ComDeepinDaemonAuthenticateSessionSkeletonClass))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON, ComDeepinDaemonAuthenticateSessionSkeletonClass))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_SKELETON))
+
+typedef struct _ComDeepinDaemonAuthenticateSessionSkeleton ComDeepinDaemonAuthenticateSessionSkeleton;
+typedef struct _ComDeepinDaemonAuthenticateSessionSkeletonClass ComDeepinDaemonAuthenticateSessionSkeletonClass;
+typedef struct _ComDeepinDaemonAuthenticateSessionSkeletonPrivate ComDeepinDaemonAuthenticateSessionSkeletonPrivate;
+
+struct _ComDeepinDaemonAuthenticateSessionSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  ComDeepinDaemonAuthenticateSessionSkeletonPrivate *priv;
+};
+
+struct _ComDeepinDaemonAuthenticateSessionSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType com_deepin_daemon_authenticate_session_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ComDeepinDaemonAuthenticateSessionSkeleton, g_object_unref)
+#endif
+
+ComDeepinDaemonAuthenticateSession *com_deepin_daemon_authenticate_session_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __COM_DEEPIN_DAEMON_AUTHENTICATE_SESSION_H__ */
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.Session.xml
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.Session.xml
@@ -0,0 +1,52 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+	 "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+    <interface name="com.deepin.daemon.Authenticate.Session">
+        <method name="EncryptKey">
+            <arg name="encryptType" type="i" direction="in"></arg>
+            <arg name="encryptMethod" type="ai" direction="in"></arg>
+            <arg name="encType" type="i" direction="out"></arg>
+            <arg name="encMethod" type="ai" direction="out"></arg>
+            <arg name="pubKey" type="s" direction="out"></arg>
+        </method>
+        <method name="End">
+            <arg name="flag" type="i" direction="in"></arg>
+            <arg name="failNum" type="i" direction="out"></arg>
+        </method>
+        <method name="GetResult">
+            <arg name="result" type="i" direction="out"></arg>
+        </method>
+        <method name="PrivilegesDisable"></method>
+        <method name="PrivilegesEnable">
+            <arg name="masterPath" type="s" direction="in"></arg>
+            <arg name="enabled" type="b" direction="out"></arg>
+        </method>
+        <method name="Quit"></method>
+        <method name="SetQuitFlag">
+            <arg name="method" type="i" direction="in"></arg>
+        </method>
+        <method name="SetToken">
+            <arg name="flag" type="i" direction="in"></arg>
+            <arg name="token" type="ay" direction="in"></arg>
+        </method>
+        <method name="Start">
+            <arg name="flag" type="i" direction="in"></arg>
+            <arg name="timeout" type="i" direction="in"></arg>
+            <arg name="failNum" type="i" direction="out"></arg>
+        </method>
+        <method name="SetSymmetricKey">
+            <arg name="key" type="ay" direction="in"></arg>
+        </method>
+        <signal name="Status">
+            <arg name="flag" type="i"></arg>
+            <arg name="status" type="i"></arg>
+            <arg name="msg" type="s"></arg>
+        </signal>
+        <property name="IsMFA" type="b" access="read"></property>
+        <property name="Prompt" type="s" access="read"></property>
+        <property name="FactorsInfo" type="a(iiib)" access="read"></property>
+        <property name="Username" type="s" access="read"></property>
+        <property name="PINLen" type="i" access="read"></property>
+        <property name="PrgPath" type="s" access="read"></property>
+    </interface>
+</node>
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.c
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.c
@@ -0,0 +1,2091 @@
+/*
+ * Generated by gdbus-codegen 2.58.3 from com.deepin.daemon.Authenticate.xml. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "com.deepin.daemon.Authenticate.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  gboolean use_gvariant;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface com.deepin.daemon.Authenticate
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:ComDeepinDaemonAuthenticate
+ * @title: ComDeepinDaemonAuthenticate
+ * @short_description: Generated C code for the com.deepin.daemon.Authenticate D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for com.deepin.daemon.Authenticate ---- */
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_username =
+{
+  {
+    -1,
+    (gchar *) "username",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_authFlags =
+{
+  {
+    -1,
+    (gchar *) "authFlags",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_appType =
+{
+  {
+    -1,
+    (gchar *) "appType",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_username.parent_struct,
+  &_com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_authFlags.parent_struct,
+  &_com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_appType.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_authenticate_OUT_ARG_path =
+{
+  {
+    -1,
+    (gchar *) "path",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_authenticate_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_authenticate_OUT_ARG_path.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_method_info_authenticate =
+{
+  {
+    -1,
+    (gchar *) "Authenticate",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_authenticate_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_authenticate_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-authenticate",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_get_limits_IN_ARG_username =
+{
+  {
+    -1,
+    (gchar *) "username",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_get_limits_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_get_limits_IN_ARG_username.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_get_limits_OUT_ARG_limits =
+{
+  {
+    -1,
+    (gchar *) "limits",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_get_limits_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_get_limits_OUT_ARG_limits.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_method_info_get_limits =
+{
+  {
+    -1,
+    (gchar *) "GetLimits",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_get_limits_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_get_limits_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-get-limits",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_pre_one_key_login_IN_ARG_flag =
+{
+  {
+    -1,
+    (gchar *) "flag",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_pre_one_key_login_IN_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_pre_one_key_login_IN_ARG_flag.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_method_info_pre_one_key_login_OUT_ARG_result =
+{
+  {
+    -1,
+    (gchar *) "result",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_method_info_pre_one_key_login_OUT_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_pre_one_key_login_OUT_ARG_result.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _com_deepin_daemon_authenticate_method_info_pre_one_key_login =
+{
+  {
+    -1,
+    (gchar *) "PreOneKeyLogin",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_pre_one_key_login_IN_ARG_pointers,
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_method_info_pre_one_key_login_OUT_ARG_pointers,
+    NULL
+  },
+  "handle-pre-one-key-login",
+  FALSE
+};
+
+static const GDBusMethodInfo * const _com_deepin_daemon_authenticate_method_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_method_info_authenticate.parent_struct,
+  &_com_deepin_daemon_authenticate_method_info_get_limits.parent_struct,
+  &_com_deepin_daemon_authenticate_method_info_pre_one_key_login.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _com_deepin_daemon_authenticate_signal_info_limit_updated_ARG_username =
+{
+  {
+    -1,
+    (gchar *) "username",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const GDBusArgInfo * const _com_deepin_daemon_authenticate_signal_info_limit_updated_ARG_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_signal_info_limit_updated_ARG_username.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _com_deepin_daemon_authenticate_signal_info_limit_updated =
+{
+  {
+    -1,
+    (gchar *) "LimitUpdated",
+    (GDBusArgInfo **) &_com_deepin_daemon_authenticate_signal_info_limit_updated_ARG_pointers,
+    NULL
+  },
+  "limit-updated"
+};
+
+static const GDBusSignalInfo * const _com_deepin_daemon_authenticate_signal_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_signal_info_limit_updated.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_property_info_support_encrypts =
+{
+  {
+    -1,
+    (gchar *) "SupportEncrypts",
+    (gchar *) "s",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "support-encrypts",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_property_info_framework_state =
+{
+  {
+    -1,
+    (gchar *) "FrameworkState",
+    (gchar *) "i",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "framework-state",
+  FALSE
+};
+
+static const _ExtendedGDBusPropertyInfo _com_deepin_daemon_authenticate_property_info_supported_flags =
+{
+  {
+    -1,
+    (gchar *) "SupportedFlags",
+    (gchar *) "i",
+    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
+    NULL
+  },
+  "supported-flags",
+  FALSE
+};
+
+static const GDBusPropertyInfo * const _com_deepin_daemon_authenticate_property_info_pointers[] =
+{
+  &_com_deepin_daemon_authenticate_property_info_support_encrypts.parent_struct,
+  &_com_deepin_daemon_authenticate_property_info_framework_state.parent_struct,
+  &_com_deepin_daemon_authenticate_property_info_supported_flags.parent_struct,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _com_deepin_daemon_authenticate_interface_info =
+{
+  {
+    -1,
+    (gchar *) "com.deepin.daemon.Authenticate",
+    (GDBusMethodInfo **) &_com_deepin_daemon_authenticate_method_info_pointers,
+    (GDBusSignalInfo **) &_com_deepin_daemon_authenticate_signal_info_pointers,
+    (GDBusPropertyInfo **) &_com_deepin_daemon_authenticate_property_info_pointers,
+    NULL
+  },
+  "com-deepin-daemon-authenticate",
+};
+
+
+/**
+ * com_deepin_daemon_authenticate_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+com_deepin_daemon_authenticate_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct;
+}
+
+/**
+ * com_deepin_daemon_authenticate_override_properties:
+ * @klass: The class structure for a #GObject derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #ComDeepinDaemonAuthenticate interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+com_deepin_daemon_authenticate_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  g_object_class_override_property (klass, property_id_begin++, "support-encrypts");
+  g_object_class_override_property (klass, property_id_begin++, "framework-state");
+  g_object_class_override_property (klass, property_id_begin++, "supported-flags");
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * ComDeepinDaemonAuthenticate:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link>.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateIface:
+ * @parent_iface: The parent interface.
+ * @handle_authenticate: Handler for the #ComDeepinDaemonAuthenticate::handle-authenticate signal.
+ * @handle_get_limits: Handler for the #ComDeepinDaemonAuthenticate::handle-get-limits signal.
+ * @handle_pre_one_key_login: Handler for the #ComDeepinDaemonAuthenticate::handle-pre-one-key-login signal.
+ * @get_framework_state: Getter for the #ComDeepinDaemonAuthenticate:framework-state property.
+ * @get_support_encrypts: Getter for the #ComDeepinDaemonAuthenticate:support-encrypts property.
+ * @get_supported_flags: Getter for the #ComDeepinDaemonAuthenticate:supported-flags property.
+ * @limit_updated: Handler for the #ComDeepinDaemonAuthenticate::limit-updated signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link>.
+ */
+
+typedef ComDeepinDaemonAuthenticateIface ComDeepinDaemonAuthenticateInterface;
+G_DEFINE_INTERFACE (ComDeepinDaemonAuthenticate, com_deepin_daemon_authenticate, G_TYPE_OBJECT)
+
+static void
+com_deepin_daemon_authenticate_default_init (ComDeepinDaemonAuthenticateIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * ComDeepinDaemonAuthenticate::handle-authenticate:
+   * @object: A #ComDeepinDaemonAuthenticate.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_username: Argument passed by remote caller.
+   * @arg_authFlags: Argument passed by remote caller.
+   * @arg_appType: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.Authenticate">Authenticate()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_complete_authenticate() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-authenticate",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateIface, handle_authenticate),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_INT, G_TYPE_INT);
+
+  /**
+   * ComDeepinDaemonAuthenticate::handle-get-limits:
+   * @object: A #ComDeepinDaemonAuthenticate.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_username: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.GetLimits">GetLimits()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_complete_get_limits() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-get-limits",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateIface, handle_get_limits),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /**
+   * ComDeepinDaemonAuthenticate::handle-pre-one-key-login:
+   * @object: A #ComDeepinDaemonAuthenticate.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_flag: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.PreOneKeyLogin">PreOneKeyLogin()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call com_deepin_daemon_authenticate_complete_pre_one_key_login() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-pre-one-key-login",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateIface, handle_pre_one_key_login),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * ComDeepinDaemonAuthenticate::limit-updated:
+   * @object: A #ComDeepinDaemonAuthenticate.
+   * @arg_username: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-deepin-daemon-Authenticate.LimitUpdated">"LimitUpdated"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("limit-updated",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ComDeepinDaemonAuthenticateIface, limit_updated),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    1, G_TYPE_STRING);
+
+  /* GObject properties for D-Bus properties: */
+  /**
+   * ComDeepinDaemonAuthenticate:support-encrypts:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportEncrypts">"SupportEncrypts"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_string ("support-encrypts", "SupportEncrypts", "SupportEncrypts", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticate:framework-state:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate.FrameworkState">"FrameworkState"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int ("framework-state", "FrameworkState", "FrameworkState", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * ComDeepinDaemonAuthenticate:supported-flags:
+   *
+   * Represents the D-Bus property <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportedFlags">"SupportedFlags"</link>.
+   *
+   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
+   */
+  g_object_interface_install_property (iface,
+    g_param_spec_int ("supported-flags", "SupportedFlags", "SupportedFlags", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+/**
+ * com_deepin_daemon_authenticate_get_support_encrypts: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportEncrypts">"SupportEncrypts"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use com_deepin_daemon_authenticate_dup_support_encrypts() if on another thread.</warning>
+ *
+ * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
+ */
+const gchar *
+com_deepin_daemon_authenticate_get_support_encrypts (ComDeepinDaemonAuthenticate *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_GET_IFACE (object)->get_support_encrypts (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_dup_support_encrypts: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ *
+ * Gets a copy of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportEncrypts">"SupportEncrypts"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
+ */
+gchar *
+com_deepin_daemon_authenticate_dup_support_encrypts (ComDeepinDaemonAuthenticate *object)
+{
+  gchar *value;
+  g_object_get (G_OBJECT (object), "support-encrypts", &value, NULL);
+  return value;
+}
+
+/**
+ * com_deepin_daemon_authenticate_set_support_encrypts: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportEncrypts">"SupportEncrypts"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_set_support_encrypts (ComDeepinDaemonAuthenticate *object, const gchar *value)
+{
+  g_object_set (G_OBJECT (object), "support-encrypts", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_get_framework_state: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.FrameworkState">"FrameworkState"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint 
+com_deepin_daemon_authenticate_get_framework_state (ComDeepinDaemonAuthenticate *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_GET_IFACE (object)->get_framework_state (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_set_framework_state: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.FrameworkState">"FrameworkState"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_set_framework_state (ComDeepinDaemonAuthenticate *object, gint value)
+{
+  g_object_set (G_OBJECT (object), "framework-state", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_get_supported_flags: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ *
+ * Gets the value of the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportedFlags">"SupportedFlags"</link> D-Bus property.
+ *
+ * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
+ *
+ * Returns: The property value.
+ */
+gint 
+com_deepin_daemon_authenticate_get_supported_flags (ComDeepinDaemonAuthenticate *object)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE_GET_IFACE (object)->get_supported_flags (object);
+}
+
+/**
+ * com_deepin_daemon_authenticate_set_supported_flags: (skip)
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @value: The value to set.
+ *
+ * Sets the <link linkend="gdbus-property-com-deepin-daemon-Authenticate.SupportedFlags">"SupportedFlags"</link> D-Bus property to @value.
+ *
+ * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
+ */
+void
+com_deepin_daemon_authenticate_set_supported_flags (ComDeepinDaemonAuthenticate *object, gint value)
+{
+  g_object_set (G_OBJECT (object), "supported-flags", value, NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_emit_limit_updated:
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @arg_username: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-com-deepin-daemon-Authenticate.LimitUpdated">"LimitUpdated"</link> D-Bus signal.
+ */
+void
+com_deepin_daemon_authenticate_emit_limit_updated (
+    ComDeepinDaemonAuthenticate *object,
+    const gchar *arg_username)
+{
+  g_signal_emit_by_name (object, "limit-updated", arg_username);
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_authenticate:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_username: Argument to pass with the method invocation.
+ * @arg_authFlags: Argument to pass with the method invocation.
+ * @arg_appType: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.Authenticate">Authenticate()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_call_authenticate_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_call_authenticate_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_call_authenticate (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gint arg_authFlags,
+    gint arg_appType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Authenticate",
+    g_variant_new ("(sii)",
+                   arg_username,
+                   arg_authFlags,
+                   arg_appType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_authenticate_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @out_path: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_call_authenticate().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_call_authenticate().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_authenticate_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_path,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_path);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_authenticate_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_username: Argument to pass with the method invocation.
+ * @arg_authFlags: Argument to pass with the method invocation.
+ * @arg_appType: Argument to pass with the method invocation.
+ * @out_path: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.Authenticate">Authenticate()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_call_authenticate() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_authenticate_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gint arg_authFlags,
+    gint arg_appType,
+    gchar **out_path,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Authenticate",
+    g_variant_new ("(sii)",
+                   arg_username,
+                   arg_authFlags,
+                   arg_appType),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_path);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_get_limits:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_username: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.GetLimits">GetLimits()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_call_get_limits_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_call_get_limits_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_call_get_limits (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "GetLimits",
+    g_variant_new ("(s)",
+                   arg_username),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_get_limits_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @out_limits: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_call_get_limits().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_call_get_limits().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_get_limits_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_limits,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_limits);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_get_limits_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_username: Argument to pass with the method invocation.
+ * @out_limits: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.GetLimits">GetLimits()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_call_get_limits() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_get_limits_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gchar **out_limits,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "GetLimits",
+    g_variant_new ("(s)",
+                   arg_username),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_limits);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_pre_one_key_login:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.PreOneKeyLogin">PreOneKeyLogin()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_call_pre_one_key_login_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_call_pre_one_key_login_sync() for the synchronous, blocking version of this method.
+ */
+void
+com_deepin_daemon_authenticate_call_pre_one_key_login (
+    ComDeepinDaemonAuthenticate *proxy,
+    gint arg_flag,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "PreOneKeyLogin",
+    g_variant_new ("(i)",
+                   arg_flag),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_pre_one_key_login_finish:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @out_result: (out): Return location for return parameter or %NULL to ignore.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_call_pre_one_key_login().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_call_pre_one_key_login().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_pre_one_key_login_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_result,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_call_pre_one_key_login_sync:
+ * @proxy: A #ComDeepinDaemonAuthenticateProxy.
+ * @arg_flag: Argument to pass with the method invocation.
+ * @out_result: (out): Return location for return parameter or %NULL to ignore.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.PreOneKeyLogin">PreOneKeyLogin()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_call_pre_one_key_login() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+com_deepin_daemon_authenticate_call_pre_one_key_login_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    gint arg_flag,
+    gchar **out_result,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "PreOneKeyLogin",
+    g_variant_new ("(i)",
+                   arg_flag),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "(s)",
+                 out_result);
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_complete_authenticate:
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @path: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.Authenticate">Authenticate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_complete_authenticate (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *path)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   path));
+}
+
+/**
+ * com_deepin_daemon_authenticate_complete_get_limits:
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @limits: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.GetLimits">GetLimits()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_complete_get_limits (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *limits)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   limits));
+}
+
+/**
+ * com_deepin_daemon_authenticate_complete_pre_one_key_login:
+ * @object: A #ComDeepinDaemonAuthenticate.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ * @result: Parameter to return.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-deepin-daemon-Authenticate.PreOneKeyLogin">PreOneKeyLogin()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+com_deepin_daemon_authenticate_complete_pre_one_key_login (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *result)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("(s)",
+                   result));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ComDeepinDaemonAuthenticateProxy:
+ *
+ * The #ComDeepinDaemonAuthenticateProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ComDeepinDaemonAuthenticateProxy.
+ */
+
+struct _ComDeepinDaemonAuthenticateProxyPrivate
+{
+  GData *qdata;
+};
+
+static void com_deepin_daemon_authenticate_proxy_iface_init (ComDeepinDaemonAuthenticateIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateProxy, com_deepin_daemon_authenticate_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (ComDeepinDaemonAuthenticateProxy)
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, com_deepin_daemon_authenticate_proxy_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateProxy, com_deepin_daemon_authenticate_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, com_deepin_daemon_authenticate_proxy_iface_init))
+
+#endif
+static void
+com_deepin_daemon_authenticate_proxy_finalize (GObject *object)
+{
+  ComDeepinDaemonAuthenticateProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (com_deepin_daemon_authenticate_proxy_parent_class)->finalize (object);
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  info = (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_property_info_pointers[prop_id - 1];
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
+  if (info->use_gvariant)
+    {
+      g_value_set_variant (value, variant);
+    }
+  else
+    {
+      if (variant != NULL)
+        g_dbus_gvariant_to_gvalue (variant, value);
+    }
+  if (variant != NULL)
+    g_variant_unref (variant);
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_set_property_cb (GDBusProxy *proxy,
+  GAsyncResult *res,
+  gpointer      user_data)
+{
+  const _ExtendedGDBusPropertyInfo *info = user_data;
+  GError *error;
+  GVariant *_ret;
+  error = NULL;
+  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
+  if (!_ret)
+    {
+      g_warning ("Error setting property '%s' on interface com.deepin.daemon.Authenticate: %s (%s, %d)",
+                 info->parent_struct.name, 
+                 error->message, g_quark_to_string (error->domain), error->code);
+      g_error_free (error);
+    }
+  else
+    {
+      g_variant_unref (_ret);
+    }
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  GVariant *variant;
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  info = (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_property_info_pointers[prop_id - 1];
+  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
+  g_dbus_proxy_call (G_DBUS_PROXY (object),
+    "org.freedesktop.DBus.Properties.Set",
+    g_variant_new ("(ssv)", "com.deepin.daemon.Authenticate", info->parent_struct.name, variant),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    NULL, (GAsyncReadyCallback) com_deepin_daemon_authenticate_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
+  g_variant_unref (variant);
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  gsize n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  ComDeepinDaemonAuthenticateProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_proxy_get_support_encrypts (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (object);
+  GVariant *variant;
+  const gchar *value = NULL;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SupportEncrypts");
+  if (variant != NULL)
+    {
+      value = g_variant_get_string (variant, NULL);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_proxy_get_framework_state (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (object);
+  GVariant *variant;
+  gint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FrameworkState");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_proxy_get_supported_flags (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateProxy *proxy = COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (object);
+  GVariant *variant;
+  gint value = 0;
+  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SupportedFlags");
+  if (variant != NULL)
+    {
+      value = g_variant_get_int32 (variant);
+      g_variant_unref (variant);
+    }
+  return value;
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_init (ComDeepinDaemonAuthenticateProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = com_deepin_daemon_authenticate_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, ComDeepinDaemonAuthenticateProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), com_deepin_daemon_authenticate_interface_info ());
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_class_init (ComDeepinDaemonAuthenticateProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = com_deepin_daemon_authenticate_proxy_finalize;
+  gobject_class->get_property = com_deepin_daemon_authenticate_proxy_get_property;
+  gobject_class->set_property = com_deepin_daemon_authenticate_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = com_deepin_daemon_authenticate_proxy_g_signal;
+  proxy_class->g_properties_changed = com_deepin_daemon_authenticate_proxy_g_properties_changed;
+
+  com_deepin_daemon_authenticate_override_properties (gobject_class, 1);
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ComDeepinDaemonAuthenticateProxyPrivate));
+#endif
+}
+
+static void
+com_deepin_daemon_authenticate_proxy_iface_init (ComDeepinDaemonAuthenticateIface *iface)
+{
+  iface->get_support_encrypts = com_deepin_daemon_authenticate_proxy_get_support_encrypts;
+  iface->get_framework_state = com_deepin_daemon_authenticate_proxy_get_framework_state;
+  iface->get_supported_flags = com_deepin_daemon_authenticate_proxy_get_supported_flags;
+}
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_proxy_new_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+com_deepin_daemon_authenticate_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate", NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_proxy_new().
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticate *
+com_deepin_daemon_authenticate_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE (ret);
+  else
+    return NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (nullable): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticate *
+com_deepin_daemon_authenticate_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate", NULL);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like com_deepin_daemon_authenticate_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call com_deepin_daemon_authenticate_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See com_deepin_daemon_authenticate_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+com_deepin_daemon_authenticate_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate", NULL);
+}
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to com_deepin_daemon_authenticate_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with com_deepin_daemon_authenticate_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticate *
+com_deepin_daemon_authenticate_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE (ret);
+  else
+    return NULL;
+}
+
+/**
+ * com_deepin_daemon_authenticate_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (nullable): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like com_deepin_daemon_authenticate_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See com_deepin_daemon_authenticate_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ComDeepinDaemonAuthenticate *
+com_deepin_daemon_authenticate_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.deepin.daemon.Authenticate", NULL);
+  if (ret != NULL)
+    return COM_DEEPIN_DAEMON_AUTHENTICATE (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ComDeepinDaemonAuthenticateSkeleton:
+ *
+ * The #ComDeepinDaemonAuthenticateSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ComDeepinDaemonAuthenticateSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ComDeepinDaemonAuthenticateSkeleton.
+ */
+
+struct _ComDeepinDaemonAuthenticateSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_com_deepin_daemon_authenticate_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  gsize num_params;
+  guint num_extra;
+  gsize n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_com_deepin_daemon_authenticate_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_com_deepin_daemon_authenticate_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_com_deepin_daemon_authenticate_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _com_deepin_daemon_authenticate_skeleton_vtable =
+{
+  _com_deepin_daemon_authenticate_skeleton_handle_method_call,
+  _com_deepin_daemon_authenticate_skeleton_handle_get_property,
+  _com_deepin_daemon_authenticate_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+com_deepin_daemon_authenticate_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return com_deepin_daemon_authenticate_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+com_deepin_daemon_authenticate_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_com_deepin_daemon_authenticate_skeleton_vtable;
+}
+
+static GVariant *
+com_deepin_daemon_authenticate_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_com_deepin_daemon_authenticate_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _com_deepin_daemon_authenticate_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _com_deepin_daemon_authenticate_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _com_deepin_daemon_authenticate_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.deepin.daemon.Authenticate", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static gboolean _com_deepin_daemon_authenticate_emit_changed (gpointer user_data);
+
+static void
+com_deepin_daemon_authenticate_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (_skeleton);
+  gboolean emit_changed = FALSE;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    {
+      g_source_destroy (skeleton->priv->changed_properties_idle_source);
+      skeleton->priv->changed_properties_idle_source = NULL;
+      emit_changed = TRUE;
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+
+  if (emit_changed)
+    _com_deepin_daemon_authenticate_emit_changed (skeleton);
+}
+
+static void
+_com_deepin_daemon_authenticate_on_signal_limit_updated (
+    ComDeepinDaemonAuthenticate *object,
+    const gchar *arg_username)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
+                   arg_username));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.deepin.daemon.Authenticate", "LimitUpdated",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void com_deepin_daemon_authenticate_skeleton_iface_init (ComDeepinDaemonAuthenticateIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSkeleton, com_deepin_daemon_authenticate_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (ComDeepinDaemonAuthenticateSkeleton)
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, com_deepin_daemon_authenticate_skeleton_iface_init))
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ComDeepinDaemonAuthenticateSkeleton, com_deepin_daemon_authenticate_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, com_deepin_daemon_authenticate_skeleton_iface_init))
+
+#endif
+static void
+com_deepin_daemon_authenticate_skeleton_finalize (GObject *object)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  guint n;
+  for (n = 0; n < 3; n++)
+    g_value_unset (&skeleton->priv->properties[n]);
+  g_free (skeleton->priv->properties);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (com_deepin_daemon_authenticate_skeleton_parent_class)->finalize (object);
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static gboolean
+_com_deepin_daemon_authenticate_emit_changed (gpointer user_data)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (user_data);
+  GList *l;
+  GVariantBuilder builder;
+  GVariantBuilder invalidated_builder;
+  guint num_changes;
+
+  g_mutex_lock (&skeleton->priv->lock);
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
+  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
+    {
+      ChangedProperty *cp = l->data;
+      GVariant *variant;
+      const GValue *cur_value;
+
+      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
+      if (!_g_value_equal (cur_value, &cp->orig_value))
+        {
+          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
+          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
+          g_variant_unref (variant);
+          num_changes++;
+        }
+    }
+  if (num_changes > 0)
+    {
+      GList *connections, *ll;
+      GVariant *signal_variant;
+      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "com.deepin.daemon.Authenticate",
+                                           &builder, &invalidated_builder));
+      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+      for (ll = connections; ll != NULL; ll = ll->next)
+        {
+          GDBusConnection *connection = ll->data;
+
+          g_dbus_connection_emit_signal (connection,
+                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
+                                         "org.freedesktop.DBus.Properties",
+                                         "PropertiesChanged",
+                                         signal_variant,
+                                         NULL);
+        }
+      g_variant_unref (signal_variant);
+      g_list_free_full (connections, g_object_unref);
+    }
+  else
+    {
+      g_variant_builder_clear (&builder);
+      g_variant_builder_clear (&invalidated_builder);
+    }
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  skeleton->priv->changed_properties = NULL;
+  skeleton->priv->changed_properties_idle_source = NULL;
+  g_mutex_unlock (&skeleton->priv->lock);
+  return FALSE;
+}
+
+static void
+_com_deepin_daemon_authenticate_schedule_emit_changed (ComDeepinDaemonAuthenticateSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
+{
+  ChangedProperty *cp;
+  GList *l;
+  cp = NULL;
+  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
+    {
+      ChangedProperty *i_cp = l->data;
+      if (i_cp->info == info)
+        {
+          cp = i_cp;
+          break;
+        }
+    }
+  if (cp == NULL)
+    {
+      cp = g_new0 (ChangedProperty, 1);
+      cp->prop_id = prop_id;
+      cp->info = info;
+      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
+      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
+      g_value_copy (orig_value, &cp->orig_value);
+    }
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_notify (GObject      *object,
+  GParamSpec *pspec G_GNUC_UNUSED)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  g_mutex_lock (&skeleton->priv->lock);
+  if (skeleton->priv->changed_properties != NULL &&
+      skeleton->priv->changed_properties_idle_source == NULL)
+    {
+      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
+      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
+      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _com_deepin_daemon_authenticate_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
+      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _com_deepin_daemon_authenticate_emit_changed");
+      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
+      g_source_unref (skeleton->priv->changed_properties_idle_source);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  g_assert (prop_id != 0 && prop_id - 1 < 3);
+  g_mutex_lock (&skeleton->priv->lock);
+  g_object_freeze_notify (object);
+  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
+    {
+      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
+        _com_deepin_daemon_authenticate_schedule_emit_changed (skeleton, (const _ExtendedGDBusPropertyInfo *) _com_deepin_daemon_authenticate_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
+      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
+      g_object_notify_by_pspec (object, pspec);
+    }
+  g_mutex_unlock (&skeleton->priv->lock);
+  g_object_thaw_notify (object);
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_init (ComDeepinDaemonAuthenticateSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = com_deepin_daemon_authenticate_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON, ComDeepinDaemonAuthenticateSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+  skeleton->priv->properties = g_new0 (GValue, 3);
+  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
+  g_value_init (&skeleton->priv->properties[1], G_TYPE_INT);
+  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
+}
+
+static const gchar *
+com_deepin_daemon_authenticate_skeleton_get_support_encrypts (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  const gchar *value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_string (&(skeleton->priv->properties[0]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_skeleton_get_framework_state (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  gint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int (&(skeleton->priv->properties[1]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static gint 
+com_deepin_daemon_authenticate_skeleton_get_supported_flags (ComDeepinDaemonAuthenticate *object)
+{
+  ComDeepinDaemonAuthenticateSkeleton *skeleton = COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (object);
+  gint value;
+  g_mutex_lock (&skeleton->priv->lock);
+  value = g_value_get_int (&(skeleton->priv->properties[2]));
+  g_mutex_unlock (&skeleton->priv->lock);
+  return value;
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_class_init (ComDeepinDaemonAuthenticateSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = com_deepin_daemon_authenticate_skeleton_finalize;
+  gobject_class->get_property = com_deepin_daemon_authenticate_skeleton_get_property;
+  gobject_class->set_property = com_deepin_daemon_authenticate_skeleton_set_property;
+  gobject_class->notify       = com_deepin_daemon_authenticate_skeleton_notify;
+
+
+  com_deepin_daemon_authenticate_override_properties (gobject_class, 1);
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = com_deepin_daemon_authenticate_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = com_deepin_daemon_authenticate_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = com_deepin_daemon_authenticate_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = com_deepin_daemon_authenticate_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ComDeepinDaemonAuthenticateSkeletonPrivate));
+#endif
+}
+
+static void
+com_deepin_daemon_authenticate_skeleton_iface_init (ComDeepinDaemonAuthenticateIface *iface)
+{
+  iface->limit_updated = _com_deepin_daemon_authenticate_on_signal_limit_updated;
+  iface->get_support_encrypts = com_deepin_daemon_authenticate_skeleton_get_support_encrypts;
+  iface->get_framework_state = com_deepin_daemon_authenticate_skeleton_get_framework_state;
+  iface->get_supported_flags = com_deepin_daemon_authenticate_skeleton_get_supported_flags;
+}
+
+/**
+ * com_deepin_daemon_authenticate_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-deepin-daemon-Authenticate.top_of_page">com.deepin.daemon.Authenticate</link>.
+ *
+ * Returns: (transfer full) (type ComDeepinDaemonAuthenticateSkeleton): The skeleton object.
+ */
+ComDeepinDaemonAuthenticate *
+com_deepin_daemon_authenticate_skeleton_new (void)
+{
+  return COM_DEEPIN_DAEMON_AUTHENTICATE (g_object_new (TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON, NULL));
+}
+
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.h
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.h
@@ -0,0 +1,279 @@
+/*
+ * Generated by gdbus-codegen 2.58.3 from com.deepin.daemon.Authenticate.xml. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the D-Bus interface description
+ * it was derived from.
+ */
+
+#ifndef __COM_DEEPIN_DAEMON_AUTHENTICATE_H__
+#define __COM_DEEPIN_DAEMON_AUTHENTICATE_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for com.deepin.daemon.Authenticate */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE (com_deepin_daemon_authenticate_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, ComDeepinDaemonAuthenticate))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE, ComDeepinDaemonAuthenticateIface))
+
+struct _ComDeepinDaemonAuthenticate;
+typedef struct _ComDeepinDaemonAuthenticate ComDeepinDaemonAuthenticate;
+typedef struct _ComDeepinDaemonAuthenticateIface ComDeepinDaemonAuthenticateIface;
+
+struct _ComDeepinDaemonAuthenticateIface
+{
+  GTypeInterface parent_iface;
+
+
+
+  gboolean (*handle_authenticate) (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_username,
+    gint arg_authFlags,
+    gint arg_appType);
+
+  gboolean (*handle_get_limits) (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_username);
+
+  gboolean (*handle_pre_one_key_login) (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    gint arg_flag);
+
+  gint  (*get_framework_state) (ComDeepinDaemonAuthenticate *object);
+
+  const gchar * (*get_support_encrypts) (ComDeepinDaemonAuthenticate *object);
+
+  gint  (*get_supported_flags) (ComDeepinDaemonAuthenticate *object);
+
+  void (*limit_updated) (
+    ComDeepinDaemonAuthenticate *object,
+    const gchar *arg_username);
+
+};
+
+GType com_deepin_daemon_authenticate_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *com_deepin_daemon_authenticate_interface_info (void);
+guint com_deepin_daemon_authenticate_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void com_deepin_daemon_authenticate_complete_authenticate (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *path);
+
+void com_deepin_daemon_authenticate_complete_get_limits (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *limits);
+
+void com_deepin_daemon_authenticate_complete_pre_one_key_login (
+    ComDeepinDaemonAuthenticate *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *result);
+
+
+
+/* D-Bus signal emissions functions: */
+void com_deepin_daemon_authenticate_emit_limit_updated (
+    ComDeepinDaemonAuthenticate *object,
+    const gchar *arg_username);
+
+
+
+/* D-Bus method calls: */
+void com_deepin_daemon_authenticate_call_authenticate (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gint arg_authFlags,
+    gint arg_appType,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_call_authenticate_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_path,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_call_authenticate_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gint arg_authFlags,
+    gint arg_appType,
+    gchar **out_path,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_call_get_limits (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_call_get_limits_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_limits,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_call_get_limits_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    const gchar *arg_username,
+    gchar **out_limits,
+    GCancellable *cancellable,
+    GError **error);
+
+void com_deepin_daemon_authenticate_call_pre_one_key_login (
+    ComDeepinDaemonAuthenticate *proxy,
+    gint arg_flag,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean com_deepin_daemon_authenticate_call_pre_one_key_login_finish (
+    ComDeepinDaemonAuthenticate *proxy,
+    gchar **out_result,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean com_deepin_daemon_authenticate_call_pre_one_key_login_sync (
+    ComDeepinDaemonAuthenticate *proxy,
+    gint arg_flag,
+    gchar **out_result,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* D-Bus property accessors: */
+const gchar *com_deepin_daemon_authenticate_get_support_encrypts (ComDeepinDaemonAuthenticate *object);
+gchar *com_deepin_daemon_authenticate_dup_support_encrypts (ComDeepinDaemonAuthenticate *object);
+void com_deepin_daemon_authenticate_set_support_encrypts (ComDeepinDaemonAuthenticate *object, const gchar *value);
+
+gint com_deepin_daemon_authenticate_get_framework_state (ComDeepinDaemonAuthenticate *object);
+void com_deepin_daemon_authenticate_set_framework_state (ComDeepinDaemonAuthenticate *object, gint value);
+
+gint com_deepin_daemon_authenticate_get_supported_flags (ComDeepinDaemonAuthenticate *object);
+void com_deepin_daemon_authenticate_set_supported_flags (ComDeepinDaemonAuthenticate *object, gint value);
+
+
+/* ---- */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY (com_deepin_daemon_authenticate_proxy_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, ComDeepinDaemonAuthenticateProxy))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, ComDeepinDaemonAuthenticateProxyClass))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY, ComDeepinDaemonAuthenticateProxyClass))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_PROXY))
+
+typedef struct _ComDeepinDaemonAuthenticateProxy ComDeepinDaemonAuthenticateProxy;
+typedef struct _ComDeepinDaemonAuthenticateProxyClass ComDeepinDaemonAuthenticateProxyClass;
+typedef struct _ComDeepinDaemonAuthenticateProxyPrivate ComDeepinDaemonAuthenticateProxyPrivate;
+
+struct _ComDeepinDaemonAuthenticateProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  ComDeepinDaemonAuthenticateProxyPrivate *priv;
+};
+
+struct _ComDeepinDaemonAuthenticateProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType com_deepin_daemon_authenticate_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ComDeepinDaemonAuthenticateProxy, g_object_unref)
+#endif
+
+void com_deepin_daemon_authenticate_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ComDeepinDaemonAuthenticate *com_deepin_daemon_authenticate_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ComDeepinDaemonAuthenticate *com_deepin_daemon_authenticate_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void com_deepin_daemon_authenticate_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ComDeepinDaemonAuthenticate *com_deepin_daemon_authenticate_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ComDeepinDaemonAuthenticate *com_deepin_daemon_authenticate_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON (com_deepin_daemon_authenticate_skeleton_get_type ())
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON, ComDeepinDaemonAuthenticateSkeleton))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON, ComDeepinDaemonAuthenticateSkeletonClass))
+#define COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON, ComDeepinDaemonAuthenticateSkeletonClass))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON))
+#define IS_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_COM_DEEPIN_DAEMON_AUTHENTICATE_SKELETON))
+
+typedef struct _ComDeepinDaemonAuthenticateSkeleton ComDeepinDaemonAuthenticateSkeleton;
+typedef struct _ComDeepinDaemonAuthenticateSkeletonClass ComDeepinDaemonAuthenticateSkeletonClass;
+typedef struct _ComDeepinDaemonAuthenticateSkeletonPrivate ComDeepinDaemonAuthenticateSkeletonPrivate;
+
+struct _ComDeepinDaemonAuthenticateSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  ComDeepinDaemonAuthenticateSkeletonPrivate *priv;
+};
+
+struct _ComDeepinDaemonAuthenticateSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType com_deepin_daemon_authenticate_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ComDeepinDaemonAuthenticateSkeleton, g_object_unref)
+#endif
+
+ComDeepinDaemonAuthenticate *com_deepin_daemon_authenticate_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __COM_DEEPIN_DAEMON_AUTHENTICATE_H__ */
Index: b/src/libda/auth/com.deepin.daemon.Authenticate.xml
===================================================================
--- /dev/null
+++ b/src/libda/auth/com.deepin.daemon.Authenticate.xml
@@ -0,0 +1,26 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+	 "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+    <interface name="com.deepin.daemon.Authenticate">
+        <method name="Authenticate">
+            <arg name="username" type="s" direction="in"></arg>
+            <arg name="authFlags" type="i" direction="in"></arg>
+            <arg name="appType" type="i" direction="in"></arg>
+            <arg name="path" type="s" direction="out"></arg>
+        </method>
+        <method name="GetLimits">
+            <arg name="username" type="s" direction="in"></arg>
+            <arg name="limits" type="s" direction="out"></arg>
+        </method>
+        <method name="PreOneKeyLogin">
+            <arg name="flag" type="i" direction="in"></arg>
+            <arg name="result" type="s" direction="out"></arg>
+        </method>
+        <signal name="LimitUpdated">
+            <arg name="username" type="s"></arg>
+        </signal>
+        <property name="SupportEncrypts" type="s" access="read"></property>
+        <property name="FrameworkState" type="i" access="read"></property>
+        <property name="SupportedFlags" type="i" access="read"></property>
+    </interface>
+</node>
\ No newline at end of file
Index: b/src/libda/auth/text.c
===================================================================
--- /dev/null
+++ b/src/libda/auth/text.c
@@ -0,0 +1,363 @@
+#include "auth-priv.h"
+#include <libintl.h>
+#include <pwd.h>
+#include <limits.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include "text.h"
+#include <unistd.h>
+#include <time.h>
+#include <locale.h>
+#include <time.h>
+
+#define DOMAIN "deepin-authentication"
+
+static char *type_to_tr(DA_AUTH_FLAG auth_flag) {
+    char* text_str;
+    switch (auth_flag) {
+    // Password 有多种含义，单独的 "Password" 可表示为 "请输入密码"，此处含义为 "密码"，故屏蔽
+    // case AT_Password:
+    //     return gettext("Password");
+    case AUTH_FLAG_FINGERPRINT:
+        text_str = gettext("Fingerprint");
+        break;
+    case AUTH_FLAG_FACE:
+        text_str = gettext("Face recognition");
+        break;
+    case AUTH_FLAG_AD:
+        text_str = gettext("ActiveDirectory");
+        break;
+    case AUTH_FLAG_UKEY:
+        text_str = gettext("PIN");
+        break;
+    default:
+        text_str = gettext("Unknown");
+        break;
+    }
+    return text_str;
+}
+
+static bool is_input_type(DA_AUTH_FLAG authType) {
+    if (authType == AUTH_FLAG_PASSWORD || authType == AUTH_FLAG_UKEY || authType == AUTH_FLAG_AD) {
+        return true;
+    }
+    return false;
+}
+
+static bool is_tty() {
+    return isatty(fileno(stdin));
+}
+
+static da_limit_info *get_limit_info_priv(da_proxy *proxy,
+                                          const char *username,
+                                          DA_AUTH_FLAG auth_flag) {
+    da_limit_info *dli = NULL;
+    int dli_num = 0;
+    da_error *error = NULL;
+    da_get_limits(proxy, username, &dli, &dli_num, &error);
+    if (error) {
+        da_error_free(error);
+        return NULL;
+    }
+    da_limit_info *spec_limit = da_get_auth_limit_info(dli, dli_num, auth_flag);
+    if (!spec_limit) {
+        if (dli) {
+            free(dli);
+        }
+        return NULL;
+    }
+    da_limit_info *out_limit = malloc(sizeof(da_limit_info));
+    memcpy(out_limit, spec_limit, sizeof(da_limit_info));
+
+    if (dli) {
+        free(dli);
+    }
+
+    return out_limit;
+}
+
+static int resolve_limit_time(da_limit_info *limit) {
+    struct tm get_time = {
+            .tm_isdst = 0,
+    };
+    strptime(limit->unlock_time, "%FT%TZ", &get_time);
+    time_t now = time(NULL);
+
+    time_t get_time_timestamp = mktime(&get_time);
+
+    double diff_of_time = difftime(get_time_timestamp, now);
+
+    int minutes = 0;
+    if (diff_of_time >= 0) {
+        long long wait = diff_of_time;
+        minutes = (wait + 59) / 60;
+    }
+    return minutes;
+}
+
+static int get_limit_prompt(char *buff, da_limit_info *limit) {
+    if (limit->locked) {
+        int minutes = resolve_limit_time(limit);
+        if (minutes > 1) {
+            sprintf(buff, gettext("Please try again %d minutes later"), minutes);
+        } else {
+            sprintf(buff, gettext("Please try again %d minute later"), minutes);
+        }
+        return 1;
+    }
+    return 0;
+}
+
+void da_load_user_locale(const char *username) {
+    const char *locale_path = ".config/locale.conf";
+    struct passwd *p;
+    if ((p = getpwnam(username)) == NULL) {
+        return;
+    }
+    size_t path_len = strlen(p->pw_dir) + strlen(locale_path) + 2; // 2: '/' + '\0'
+    if (path_len > PATH_MAX) {
+        return;
+    }
+    char *buff = malloc(MAX_BUFF_SIZE);
+    strcpy(buff, p->pw_dir);
+    strcat(buff, "/");
+    strcat(buff, locale_path);
+    struct stat locale_file_stat;
+    stat(buff, &locale_file_stat);
+    if (!S_ISREG(locale_file_stat.st_mode)) {
+        free(buff);
+        return;
+    }
+    FILE *f;
+    if ((f = fopen(buff, "r")) == NULL) {
+        free(buff);
+        return;
+    }
+    char *pos = NULL;
+
+    while (fgets(buff, MAX_BUFF_SIZE, f) != NULL) {
+        if ((pos = strchr(buff, '\n')) != NULL) {
+            *pos = '\0';
+        }
+        pos = strchr(buff, '=');
+        if (pos == NULL || buff == pos) {
+            continue;
+        }
+        *pos = '\0';
+        char *value = pos + 1;
+        setenv(buff, value, true);
+    }
+    fclose(f);
+    free(buff);
+    return;
+}
+
+const char *da_success_prompt() {
+    setlocale(LC_ALL, "");
+    textdomain(DOMAIN);
+
+    return g_dgettext(DOMAIN, "Verification successful");
+}
+
+int da_get_lock_info(da_proxy *proxy,
+                     const char *username,
+                     DA_AUTH_FLAG auth_type,
+                     bool *is_lock,
+                     char **prompt) {
+    setlocale(LC_ALL, "");
+    textdomain(DOMAIN);
+
+    da_limit_info *spec_limit = get_limit_info_priv(proxy, username, auth_type);
+    if (!spec_limit) {
+        return -1;
+    }
+
+    char *buff = malloc(MAX_BUFF_SIZE);
+    if (get_limit_prompt(buff, spec_limit)) {
+        if (is_lock) {
+            *is_lock = true;
+        }
+        *prompt = buff;
+        free(spec_limit);
+        return 0;
+    }
+    free(buff);
+    free(spec_limit);
+    return -1;
+}
+
+int da_get_fail_prompt(da_proxy *proxy,
+                       DA_AUTH_FLAG auth_flag,
+                       bool with_retry_info,
+                       char **prompt) {
+
+    setlocale(LC_ALL, "");
+    textdomain(DOMAIN);
+
+    if (!proxy) {
+        return -1;
+    }
+
+    if (!is_valid_auth_flag(auth_flag)) {
+        return -1;
+    }
+
+    bool append_escape = is_tty() && is_input_type(auth_flag);
+    char *out_prompt = malloc(MAX_BUFF_SIZE);
+
+    int offset = 0;
+    if (append_escape) {
+        offset = strlen("\n");
+        memcpy(out_prompt, "\n", offset);
+    }
+    if (!with_retry_info) {
+        if (auth_flag == AUTH_FLAG_PASSWORD) {
+            snprintf(out_prompt + offset,
+                     MAX_BUFF_SIZE,
+                     g_dgettext(DOMAIN, "Password verification failed"));
+        } else {
+            snprintf(out_prompt + offset,
+                     MAX_BUFF_SIZE,
+                     g_dgettext(DOMAIN, "%s verification failed"),
+                     type_to_tr(auth_flag));
+        }
+    } else {
+        da_limit_info *spec_limit = get_limit_info_priv(proxy, proxy->username, auth_flag);
+        if (!spec_limit) {
+            free(out_prompt);
+            return -1;
+        }
+
+        bool locked = spec_limit->locked;
+        bool never_locked = spec_limit->max_tries == 0;
+        int retry_cnt = spec_limit->max_tries - spec_limit->fail_num;
+        free(spec_limit);
+        if (never_locked) {
+            if (auth_flag == AUTH_FLAG_PASSWORD) {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "Password verification failed"));
+            } else {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "%s verification failed"),
+                         type_to_tr(auth_flag));
+            }
+
+        } else if (locked) {
+            if (auth_flag == AUTH_FLAG_PASSWORD) {
+                char *limit_buff;
+                if (da_get_lock_info(proxy, proxy->username, auth_flag, NULL, &limit_buff)) {
+                    free(out_prompt);
+                    return -1;
+                }
+
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "Password locked, %s"),
+                         limit_buff);
+                free((void *)limit_buff);
+            } else {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "%s locked, use password please"),
+                         type_to_tr(auth_flag));
+            }
+        } else if (retry_cnt > 1) {
+            if (auth_flag == AUTH_FLAG_PASSWORD) {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "Password verification failed, %d chances left"),
+                         retry_cnt);
+            } else {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "%s verification failed, %d chances left"),
+                         type_to_tr(auth_flag),
+                         retry_cnt);
+            }
+        } else {
+            if (auth_flag == AUTH_FLAG_PASSWORD) {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "Password verification failed, only one chance left"));
+            } else {
+                snprintf(out_prompt + offset,
+                         MAX_BUFF_SIZE,
+                         g_dgettext(DOMAIN, "%s verification failed, only one chance left"),
+                         type_to_tr(auth_flag));
+            }
+        }
+    }
+
+    *prompt = out_prompt;
+    return 0;
+}
+
+static char *str_trim(const char *str, char c) {
+    if (!str) {
+        return NULL;
+    }
+    char *s = malloc(strlen(str) + 1);
+    memset(s, 0, strlen(str) + 1);
+
+    int str_i = 0;
+    int s_i = 0;
+    while (str[str_i] != '\0') {
+        if (str[str_i] != c) {
+            s[s_i++] = str[str_i];
+        }
+        str_i++;
+    }
+    return s;
+}
+
+int da_get_user_lang(const char *username, char **lang) {
+    if (!username) {
+        return -1;
+    }
+
+    struct passwd *pw = getpwnam(username);
+    if (!pw) {
+        return -1;
+    }
+
+    char buff[MAX_BUFF_SIZE];
+    snprintf(buff, MAX_BUFF_SIZE, "%s/.config/locale.conf", pw->pw_dir);
+    FILE *f = fopen(buff, "r");
+    if (!f) {
+        return -1;
+    }
+
+    char *pos = NULL;
+    while (fgets(buff, MAX_BUFF_SIZE, f) != NULL) {
+        if ((pos = strchr(buff, '\n')) != NULL) {
+            *pos = '\0';
+        }
+
+        // buff 不可能为 NULL
+        char *trim_space = str_trim(buff, ' ');
+        if (!trim_space) {
+            continue;
+        }
+
+        strcpy(buff, trim_space);
+        free(trim_space);
+
+        pos = strchr(buff, '=');
+        if (pos == NULL || buff == pos) {
+            continue;
+        }
+        *pos = '\0';
+        char *value = pos + 1;
+        if (strcmp(buff, "LANG") == 0) {
+            *lang = malloc(strlen(value) + 1);
+            strcpy(*lang, value);
+            fclose(f);
+            return 0;
+        }
+    }
+
+    fclose(f);
+    return -2;
+}
Index: b/src/libda/auth/text.h
===================================================================
--- /dev/null
+++ b/src/libda/auth/text.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "auth.h"
+
+void da_load_user_locale(const char *username);
+
+const char *da_success_prompt();
+
+int da_get_lock_info(da_proxy *proxy, const char *username,
+                     DA_AUTH_FLAG auth_type, bool *is_lock, char **prompt);
+
+int da_get_fail_prompt(da_proxy *proxy, DA_AUTH_FLAG auth_flag,
+                       bool with_retry_info, char **prompt);
+
+int da_get_user_lang(const char *username, char **lang);
+
+#ifdef __cplusplus
+}
+#endif
Index: b/src/libda/encrypt/aes.c
===================================================================
--- /dev/null
+++ b/src/libda/encrypt/aes.c
@@ -0,0 +1,80 @@
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/aes.h>
+#include <string.h>
+
+int aes_cbc_encrypt(const char *src,
+                    int srcLen,
+                    char *key,
+                    int keyLen,
+                    char **cipher_text,
+                    int *outLen)
+{
+    int blockCount = 0;
+    int quotient = srcLen / AES_BLOCK_SIZE;
+    int mod = srcLen % AES_BLOCK_SIZE;
+    blockCount = quotient + 1;
+
+    int padding = AES_BLOCK_SIZE - mod;
+    char *in = (char *)malloc(AES_BLOCK_SIZE * blockCount);
+    memset(in, padding, AES_BLOCK_SIZE * blockCount);
+    memcpy(in, src, srcLen);
+
+    // out
+    char *out = (char *)malloc(AES_BLOCK_SIZE * blockCount);
+    memset(out, 0x00, AES_BLOCK_SIZE * blockCount);
+    *outLen = AES_BLOCK_SIZE * blockCount;
+
+    //初始向量为全0
+    unsigned char iv[AES_BLOCK_SIZE];
+    memset(iv, 0x00, AES_BLOCK_SIZE);
+
+    //开始加密
+    AES_KEY aes;
+    if (AES_set_encrypt_key((unsigned char *)key, keyLen * 8, &aes) < 0)
+    {
+        if (in) {
+            free(in);
+        }
+        if (out) {
+            free(out);
+        }
+        return -1;
+    }
+    AES_cbc_encrypt((unsigned char *)in,
+                    (unsigned char *)out,
+                    AES_BLOCK_SIZE * blockCount,
+                    &aes,
+                    iv,
+                    AES_ENCRYPT);
+    free(in);
+    *cipher_text = out;
+
+    return 0;
+}
+
+int aes_cbc_decrypt(unsigned char *src, int src_len, unsigned char *key,
+                    int key_len, char **orig_text, int *out_len) {
+  //初始向量为全0
+  unsigned char iv[AES_BLOCK_SIZE];
+  memset(iv, 0x00, AES_BLOCK_SIZE);
+
+  //开始加密
+  AES_KEY aes;
+  if (AES_set_decrypt_key((unsigned char *)key, key_len * 8, &aes) < 0) {
+    return -1;
+  }
+  char *tmp = (char *)malloc(src_len);
+  memset(tmp, 0x00, src_len);
+  AES_cbc_encrypt((unsigned char *)src, (unsigned char *)tmp, src_len, &aes, iv,
+                  AES_DECRYPT);
+
+  // PKCS5 UNPADDING
+  int unpadding = tmp[src_len - 1];
+  *out_len = src_len - unpadding;
+  *orig_text = (char *)malloc(*out_len);
+  memcpy(*orig_text, tmp, *out_len);
+
+  free(tmp);
+  return 0;
+}
Index: b/src/libda/encrypt/aes.h
===================================================================
--- /dev/null
+++ b/src/libda/encrypt/aes.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int aes_cbc_encrypt(const char *src, int srcLen, char *key, int keyLen,
+                    char **cipher_text, int *outLen);
+
+int aes_cbc_decrypt(unsigned char *src, int src_len, unsigned char *key,
+                    int key_len, char **orig_text, int *out_len);
+
+#ifdef __cplusplus
+}
+#endif
Index: b/src/libda/encrypt/rsa.c
===================================================================
--- /dev/null
+++ b/src/libda/encrypt/rsa.c
@@ -0,0 +1,97 @@
+
+#include <openssl/rsa.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include "rsa.h"
+#include <time.h>
+#include <stdlib.h>
+#include <string.h>
+#include <glib-2.0/glib.h>
+
+struct _pub_key
+{
+    int algType;
+    int *flags;
+    char *pubkey;
+    RSA *rsa;
+};
+
+#define PKCS1_HEADER "-----BEGIN RSA PUBLIC KEY-----"
+#define PKCS8_HEADER "-----BEGIN PUBLIC KEY-----"
+
+int gen_rsa_pubkey(pub_key *pk, char *key)
+{
+    BIO *bio;
+    int ret = 0;
+
+    bio = BIO_new(BIO_s_mem());
+    if (!bio)
+    {
+        ret = -1;
+        goto finished;
+    }
+
+    BIO_puts(bio, key);
+
+    if (0 == strncmp(key, PKCS8_HEADER, strlen(PKCS8_HEADER)))
+    {
+        PEM_read_bio_RSA_PUBKEY(bio, &pk->rsa, NULL, NULL);
+    }
+    else if (0 == strncmp(key, PKCS1_HEADER, strlen(PKCS1_HEADER)))
+    {
+        PEM_read_bio_RSAPublicKey(bio, &pk->rsa, NULL, NULL);
+    }
+
+finished:
+    if (bio)
+        BIO_free(bio);
+    return ret;
+}
+
+void create_symmetric_key(char **symmetric_key)
+{
+    char *key = (char *)malloc(20);
+    srand(time(NULL));
+    int rand_num = (10000000 + rand() % 10000000) % 100000000;
+    sprintf(key, "%d%d", rand_num, rand_num);
+    *symmetric_key = g_strdup(key);
+
+    free(key);
+}
+
+int rsa_encrypt_data(pub_key *pk, char *origin_data, char **cipher_text)
+{
+    if (!pk || !pk->rsa)
+    {
+        return -1;
+    }
+
+    int clipSize = RSA_size(pk->rsa);
+    *cipher_text = (char *)malloc(clipSize);
+
+    int ret = RSA_public_encrypt(strlen(origin_data),
+                                 (const unsigned char *)origin_data,
+                                 (unsigned char *)*cipher_text,
+                                 pk->rsa,
+                                 RSA_PKCS1_PADDING);
+    return ret;
+}
+
+pub_key *create_pub_key()
+{
+    pub_key *pk = (pub_key *)malloc(sizeof(pub_key));
+    memset(pk, 0, sizeof(pub_key));
+    return pk;
+}
+
+void pub_key_free(pub_key *pk)
+{
+    if (pk)
+    {
+        if (pk->rsa)
+        {
+            RSA_free(pk->rsa);
+        }
+        free(pk);
+    }
+}
\ No newline at end of file
Index: b/src/libda/encrypt/rsa.h
===================================================================
--- /dev/null
+++ b/src/libda/encrypt/rsa.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _pub_key pub_key;
+
+pub_key *create_pub_key();
+
+void pub_key_free(pub_key *pk);
+
+int gen_rsa_pubkey(pub_key *pk, char *key);
+
+void create_symmetric_key(char **symmetric_key);
+
+int rsa_encrypt_data(pub_key *pk, char *origin_data, char **cipher_text);
+
+#ifdef __cplusplus
+}
+#endif
Index: b/configure.ac
===================================================================
--- a/configure.ac
+++ b/configure.ac
@@ -125,7 +125,7 @@ fi
 
 CFLAGS="${CFLAGS} -fPIE -pie"
 
-PKG_CHECK_MODULES(GLIB, [libdeepin-authenticate gmodule-2.0 gio-unix-2.0 >= 2.30.0 glib-2.0 json-glib-1.0 gtk+-2.0 json-c openssl])
+PKG_CHECK_MODULES(GLIB, [gmodule-2.0 gio-unix-2.0 >= 2.30.0 glib-2.0 json-glib-1.0 gtk+-2.0 json-c openssl])
 AC_SUBST(GLIB_CFLAGS)
 AC_SUBST(GLIB_LIBS)
 
Index: b/src/polkitagent/polkitagentsession.c
===================================================================
--- a/src/polkitagent/polkitagentsession.c
+++ b/src/polkitagent/polkitagentsession.c
@@ -62,7 +62,7 @@
 #include "polkitagentsession.h"
 #include <json-glib/json-glib.h>
 
-#include <libdeepin-authenticate.h>
+#include "../libda/libdeepin-authenticate.h"
 
 static gboolean
 _show_debug (void)
Index: b/src/polkitagent/polkitagenthelper-deepin.c
===================================================================
--- a/src/polkitagent/polkitagenthelper-deepin.c
+++ b/src/polkitagent/polkitagenthelper-deepin.c
@@ -2,7 +2,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <glib-2.0/glib.h>
-#include <libdeepin-authenticate.h>
+#include "../libda/libdeepin-authenticate.h"
 #include <pthread.h>
 #include <json-glib/json-glib.h>
 #include "polkitagenthelperprivate.h"
Index: b/src/polkitagent/Makefile.am
===================================================================
--- a/src/polkitagent/Makefile.am
+++ b/src/polkitagent/Makefile.am
@@ -103,6 +103,9 @@ polkit_agent_helper_1_LDADD = 						\
 
 polkit_agent_helper_deepin_SOURCES = 					\
 	polkitagenthelper-deepin.c	polkitagenthelperprivate.c	\
+	$(top_builddir)/src/libda/auth/auth.c \
+	$(top_builddir)/src/libda/auth/com.deepin.daemon.Authenticate.c $(top_builddir)/src/libda/auth/com.deepin.daemon.Authenticate.Session.c \
+	$(top_builddir)/src/libda/auth/text.c $(top_builddir)/src/libda/encrypt/aes.c $(top_builddir)/src/libda/encrypt/rsa.c \
 	$(NULL)
 
 polkit_agent_helper_deepin_CFLAGS  = 					\
